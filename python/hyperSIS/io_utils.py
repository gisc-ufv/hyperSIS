from pathlib import Path
from typing import Tuple, Dict, Any, List
import tempfile
import numpy as np
import csv

from .types import NetworkFileResult

def process_results(directory: str) -> Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:
    """
    Reads output files generated by the Fortran binary
    and returns numpy arrays.

    Adapt this to match the actual output format.
    """
    data_file = Path(directory) / "_results.dat"
    data = np.loadtxt(data_file)

    times = data[:, 0]
    rho_mean = data[:, 1]
    rho_var = data[:, 2]
    n_samples = data[:, 3]

    return times, rho_mean, rho_var, n_samples

def prepare_network_file(network_file: str, network_file_delimiter : str, network_file_comment: str, network_file_cache: bool, network_format: str) -> NetworkFileResult:
    """
    Prepares the network file for the Fortran simulation.
    """
    from pathlib import Path

    network_path = Path(network_file)
    if not network_path.exists():
        raise FileNotFoundError(f"Network file not found: {network_file}")

    dispatch = {
        "edgelist": prepare_edgelist,
        "fortran-edgelist": prepare_fortran_edgelist,
        "bipartite": prepare_bipartite,
        "xgi": prepare_xgi,
        "hif": prepare_hif,
    }

    if network_format not in dispatch:
        raise ValueError(f"Unknown network format: {network_format}")

    return dispatch[network_format](network_file, network_file_delimiter, network_file_comment, network_file_cache)

def prepare_edgelist(file: str, delimiter: str, comment: str, cache: bool) -> NetworkFileResult:
    """
    Prepares an edgelist network file for Fortran.

    Parameters
    ----------
    file : str
        Path to the input edgelist file.

    Returns
    -------
    file_fortran : str
        Path to the network file ready for Fortran.
    node_map : dict
        Mapping from original node IDs to Fortran node IDs.
    """
    file_fortran, map_file, already_exists = prepare_output_files(file, cache=cache)

    if already_exists:
        node_map = read_map(map_file)
        return str(file_fortran), node_map

    n_nodes = 0
    node_map = {}
    edges_mapped = []
    max_num_nodes_in_an_edge = 0

    # read file and collect edges and node_map
    with open(file, 'r') as f:
        for line in f:
            # skip comments
            if comment is not None and line.startswith(comment):
                continue

            # split line into nodes (strings)
            edge = line.strip().split(delimiter)
            mapped_edge = []
            for _n in edge:
                n = _n.strip()
                if n == "":
                    continue
                if n not in node_map:
                    n_nodes += 1
                    node_map[n] = n_nodes
                mapped_edge.append(node_map[n])
            edges_mapped.append(mapped_edge)
            if len(mapped_edge) > max_num_nodes_in_an_edge:
                max_num_nodes_in_an_edge = len(mapped_edge)

    # write edges
    write_edges(edges_mapped, file_fortran)

    # write node_map
    write_map(node_map, map_file)

    if max_num_nodes_in_an_edge < 2:
        raise ValueError("The edgelist must contain at least one edge with two nodes. Please check your input file and delimiter setting.")

    return str(file_fortran), node_map

def prepare_fortran_edgelist(file: str, delimiter: str, comment: str, cache: bool) -> NetworkFileResult:
    # we do not create a new file!
    return str(file), {}

def prepare_bipartite(file: str, delimiter: str, comment: str, cache: bool) -> NetworkFileResult:
    # In this case, we consider that each line contains node: edge
    file_fortran, map_file, already_exists = prepare_output_files(file, cache=cache)

    if already_exists:
        node_map = read_map(map_file)
        return file_fortran, node_map

    # If not cached, we need to process the file
    node_map = {}
    edges_mapped = {}
    with open(file, 'r') as f:
        for line in f:
            if comment is not None and line.startswith(comment):
                continue
            # Here we expect lines to be in the format "node: edge"
            parts = line.strip().split(delimiter)
            if len(parts) != 2: # we just ignore malformed lines
                continue
            _node, _edge = parts
            node = _node.strip()
            edge = _edge.strip()
            if node == "" or edge == "":
                continue
            if node not in node_map:
                node_map[node] = len(node_map) + 1
            edges_mapped[edge] = edges_mapped.get(edge, []) + [node_map[node]]

    edges_mapped = list(edges_mapped.values())

    # write edges
    write_edges(edges_mapped, file_fortran)

    # write node_map
    write_map(node_map, map_file)
    return file_fortran, node_map

def prepare_xgi(file: str, delimiter: str, comment: str, cache: bool) -> NetworkFileResult:
    # placeholder
    node_map = {node_id: i for i, node_id in enumerate(range(1, 102))}
    return file, node_map

def prepare_hif(file: str, delimiter: str, comment: str, cache: bool) -> NetworkFileResult:
    # placeholder
    node_map = {node_id: i for i, node_id in enumerate(range(1, 103))}
    return file, node_map

def prepare_output_files(input_file: str, prefix: str = "", cache: bool = False) -> Tuple[Path, Path, bool]:
    """
    Prepares the paths for Fortran-ready network files.

    Parameters
    ----------
    input_file : str
        Path to the original input file.
    prefix : str
        Optional prefix for the generated files (default: '').

    Returns
    -------
    file_fortran : Path
        Path to the Fortran-ready network file.
    map_file : Path
        Path to the node map file.
    already_exists : bool
        True if both files already exist.
    """
    input_path = Path(input_file)
    dirname = input_path.parent
    basename = input_path.name

    file_fortran = dirname / f"{prefix}.{basename}_edges.hyperSIS"
    map_file = dirname / f"{prefix}.{basename}_map_nodes.hyperSIS"

    # Check if both files already exist, but is False if not cache
    if file_fortran.exists() and map_file.exists():
        return file_fortran, map_file, True and cache

    # Test if we can write to the directory
    try:
        test_file = dirname / ".write_test"
        with open(test_file, "w") as f:
            f.write("test")
        test_file.unlink()
    except Exception:
        # Fallback to temporary directory
        tmpdir = Path(tempfile.mkdtemp())
        file_fortran = tmpdir / f"{basename}_edges.hyperSIS"
        map_file = tmpdir / f"{basename}_map_nodes.hyperSIS"

    return file_fortran, map_file, False

def write_map(mapping: Dict[Any, int], file_path: str) -> None:
    """
    Writes a mapping to a CSV file.

    Parameters
    ----------
    mapping : dict
        Dictionary mapping any hashable type to int.
    file_path : str
        Path to the CSV file to write.
    """
    file_path = Path(file_path)
    with file_path.open("w", newline="", encoding="utf-8") as f:
        writer = csv.writer(f)
        # write header
        writer.writerow(["original_id", "fortran_id"])
        # write data
        for key, value in mapping.items():
            writer.writerow([key, value])


def read_map(file_path: str) -> Dict[str, int]:
    """
    Reads a mapping from a CSV file.

    Parameters
    ----------
    file_path : str
        Path to the CSV file to read.

    Returns
    -------
    mapping : dict
        Dictionary mapping string keys to int values.
    """
    mapping = {}
    file_path = Path(file_path)
    with file_path.open("r", newline="", encoding="utf-8") as f:
        reader = csv.DictReader(f)
        for row in reader:
            key = row["original_id"]
            value = int(row["fortran_id"])
            mapping[key] = value
    return mapping

def write_edges(edges: List[List[int]], file_path: str) -> None:
    """
    Writes a list of edges to a plain text file.

    Each sublist in `edges` represents an edge (or hyperedge),
    and the integers are separated by spaces. No header is written.

    Parameters
    ----------
    edges : List[List[int]]
        List of edges (or hyperedges), each as a list of node IDs.
    file_path : str
        Path to the file to write.
    """
    file_path = Path(file_path)
    with file_path.open("w", encoding="utf-8") as f:
        for edge in edges:
            line = " ".join(str(node) for node in edge)
            f.write(f"{line}\n")
