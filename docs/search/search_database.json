var tipuesearch = {"pages":[{"title":" HyperSIS ","text":"HyperSIS Efficient Gillespie algorithms for spreading phenomena in large and heterogeneous higher-order networks Code implemented using the Fortran Package Manager . Main paper: Efficient Gillespie algorithms for spreading phenomena in large and heterogeneous higher-order networks , by Hugo P. Maia, Wesley Cota, Yamir Moreno, and Silvio C. Ferreira. Reference: arxiv:2509.20174 DOI:10.48550/arXiv.2509.20174 Hyper-SIS Dynamical Model This code simulates SIS dynamics on hypergraphs (Hyper-SIS). Each of the $N$ agents can be either susceptible ($\\sigma_i = 0$) or infected ($\\sigma_i = 1$). Infections occur via hyperedges, which are active if a critical mass of members is infected, while infected nodes recover spontaneously. Key points: Node recovery rate: $\\alpha = 1$. Hyperedge activation threshold: $\\theta(m) = 1 + (m-1)\\theta_0$, where $m$ is the hyperedge order. Infection rate as a function of hyperedge order: $\\beta(m) = \\beta[1 + b(m-1)]$. Pairwise infection rate: $\\beta(1) = \\beta$. Parameters par_b and par_theta correspond to $b$ and $\\theta_0$. See the main paper for full details. Using it as a dependency Add this package as a dependency using the Fortran Package Manager (fpm): [dependencies] hyperSIS . git = \"https://github.com/gisc-ufv/hyperSIS\" See the documentation and main program for details. Python package Installation The easiest way to use this project is through its Python interface. This package will be published on PyPI in the future. Until then, you need to clone the repository manually. Before installing, make sure that at least one Fortran compiler is available. By default, the package assumes GNU Fortran ( gfortran ) installed and available in your PATH. See Installing GFortran for help. Steps: Clone the repository: sh\ngit clone https://github.com/gisc-ufv/hyperSIS.git\ncd hyperSIS Activate your preferred Python environment (e.g., venv , conda , etc.): ```sh Example with venv python -m venv venv\nsource venv/bin/activate Example with conda conda create -n hyperSIS python=3.11\nconda activate hyperSIS\n``` Install the Python package: sh\npip install ./python Verify if gfortran and fpm are accessible: sh\ngfortran --version\nfpm --version (Optional) A Google Colab notebook demonstrating all installation and usage steps is available here . Usage See examples.ipynb for examples. Import the package with import hyperSIS as hs The simulation interface revolves around two main objects : SimulationArgs A dataclass containing all parameters required to configure a hyperSIS simulation, including network specification, algorithm choices, temporal settings, initial conditions, and epidemic parameters. run_simulation(beta1: float, args: SimulationArgs) The function that executes the simulation with the given arguments. Returns a SimulationResult object containing the processed results, including network mapping, temporal evolution, and statistics of infected nodes. Simulation arguments The SimulationArgs dataclass contains all configurable parameters for running a hyperSIS simulation. verbose: bool Enable verbose output.\n  Default: True verbose_level: str Logging level: 'info' , 'warning' , 'error' , 'debug' .\n  Default: warning seed: int Random seed for reproducibility.\n  Default: 42 remove_files: bool Remove temporary files after execution.\n  Default: False network: NetworkFormat Network specification as a tuple. Optional parameters are in brackets: (\"edgelist\", path, [delimiter], [comment], [cache]) (\"fortran-edgelist\", path, [cache]) (\"bipartite\", path, [delimiter], [comment], [cache]) (\"xgi\", name_or_object, [cache]) (\"xgi_json\", path, [cache]) (\"hif\", path, [cache]) (\"PL\", gamma, N, [sample]) Default: (\"edgelist\", \"example.edgelist\", None, \"#\", False) output_dir: Optional[str] Directory to store simulation output. If None , a temporary folder is used.\n  Default: None algorithm: str Simulation algorithm: 'HB_OGA' or 'NB_OGA' .\n  Default: HB_OGA sampler: str Sampling method: 'rejection_maxheap' or 'btree' .\n  Default: btree tmax: int Maximum simulation time.\n  Default: 100 use_qs: bool Whether to use the quasi-stationary method.\n  Default: False n_samples: int Number of samples per simulation.\n  Default: 10 time_scale: str Temporal scale for output: 'uniform' or 'powerlaw' .\n  Default: uniform initial_condition: tuple Initial state specification: ('fraction', float) → fraction of infected nodes ('number', int) → exact number of initially infected nodes\n  Default: (\"fraction\", 1.0) export_states: bool Whether to export the full state trajectory.\n  Default: False par_b: float Epidemic infection rate scale $b$ in $\\beta(m) = \\beta[1 + b(m-1)]$.\n  Default: 0.5 par_theta: float Epidemic critical mass threshold $\\theta_0$ in $\\theta(m) = 1 + (m-1)\\theta_0$.\n  Default: 0.5 Function run_simulation ( beta1 : float , args : SimulationArgs ) Runs a Hyper-SIS simulation on the specified network. Parameters: beta1: float Base infection rate $\\beta(1)$ for pairwise interactions. args: SimulationArgs Simulation parameters, including network specification, algorithm choice, number of samples, initial condition, and epidemic parameters par_b and par_theta . Returns: SimulationResult Object containing: network: NetworkFormat – the network specification used. node_map: dict – mapping from original node IDs to Fortran node IDs. temporal: TemporalResult – temporal dynamics with: t: np.ndarray – mean time per Gillespie tick. rho_avg: np.ndarray – mean number of infected nodes over all runs. rho_var: np.ndarray – variance of infected nodes. n_samples: int – number of runs where infection is non-zero. How to Cite When using this package, please cite the following paper: Efficient Gillespie algorithms for spreading phenomena in large and heterogeneous higher-order networks , by Hugo P. Maia, Wesley Cota, Yamir Moreno, and Silvio C. Ferreira (2025) Reference: arxiv:2509.20174 DOI:10.48550/arXiv.2509.20174 The BibTeX entry is: @misc { maia2025hoga , title = {Efficient Gillespie algorithms for spreading phenomena in large and heterogeneous higher-order networks} , author = {Hugo P. Maia and Wesley Cota and Yamir Moreno and Silvio C. Ferreira} , year = {2025} , eprint = {2509.20174} , archivePrefix = {arXiv} , primaryClass = {physics.soc-ph} , url = {https://arxiv.org/abs/2509.20174} , } Developer Info Wesley Cota Co-authors in main paper: Hugo P. Maia, Yamir Moreno, and Silvio C. Ferreira","tags":"home","url":"index.html"},{"title":"net_state_t – HyperSIS ","text":"type, public, extends( net_state_base_t ) :: net_state_t Inherits type~~net_state_t~2~~InheritsGraph type~net_state_t~2 net_state_t sampler_base_t sampler_base_t type~net_state_t~2->sampler_base_t possibly_quiescent_nodes_sampler type~net_state_base_t net_state_base_t type~net_state_t~2->type~net_state_base_t type~state_compartment_t~2 state_compartment_t type~net_state_t~2->type~state_compartment_t~2 infected type~dyn_parameters_t dyn_parameters_t type~net_state_base_t->type~dyn_parameters_t params type~state_compartment_base_t state_compartment_base_t type~state_compartment_t~2->type~state_compartment_base_t dynamical_list_t dynamical_list_t type~state_compartment_base_t->dynamical_list_t nodes Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer(kind=i2), public, allocatable, dimension(:) :: node_state type( dyn_parameters_t ), public :: params real(kind=dp), public :: time real(kind=dp), public :: total_rate real(kind=dp), public :: dt type(state_compartment_t), public :: infected real(kind=dp), public :: total_infection_attempt_rate real(kind=dp), public :: total_healing_rate class(sampler_base_t), public, allocatable :: possibly_quiescent_nodes_sampler Type-Bound Procedures procedure, public :: just_update_dt => dynamics_just_update_dt private  subroutine dynamics_just_update_dt(this, net, gen) Arguments Type Intent Optional Attributes Name class( net_state_base_t ) :: this class( network_t ), intent(in) :: net type(rndgen) :: gen generic, public :: init_config => net_state_init_config_node, net_state_init_config_list_of_nodes, net_state_init_random_fraction_of_nodes private  subroutine net_state_init_config_node(this, net, params, sampler_choice, node_id) Arguments Type Intent Optional Attributes Name class( net_state_base_t ) :: this type( network_t ), intent(in) :: net class( dyn_parameters_t ), intent(in) :: params character(len=*), intent(in) :: sampler_choice integer(kind=i4), intent(in) :: node_id private  subroutine net_state_init_config_list_of_nodes(this, net, params, sampler_choice, nodes) Arguments Type Intent Optional Attributes Name class( net_state_base_t ) :: this type( network_t ), intent(in) :: net class( dyn_parameters_t ), intent(in) :: params character(len=*), intent(in) :: sampler_choice integer(kind=i4), intent(in) :: nodes (:) private  subroutine net_state_init_random_fraction_of_nodes(this, net, gen, params, sampler_choice, fraction) Arguments Type Intent Optional Attributes Name class( net_state_base_t ) :: this type( network_t ), intent(in) :: net type(rndgen), intent(in) :: gen class( dyn_parameters_t ), intent(in) :: params character(len=*), intent(in) :: sampler_choice real(kind=dp), intent(in) :: fraction procedure, public :: export_nodes_states => net_state_export_nodes_states private  subroutine net_state_export_nodes_states(this, net, filename) Arguments Type Intent Optional Attributes Name class( net_state_base_t ) :: this type( network_t ), intent(in) :: net character(len=*), intent(in) :: filename procedure, public :: init => net_state_init private  subroutine net_state_init(this, net, params, sampler_choice) Arguments Type Intent Optional Attributes Name class( net_state_t ) :: this type( network_t ), intent(in) :: net class( dyn_parameters_t ), intent(in) :: params character(len=*), intent(in) :: sampler_choice procedure, public :: add_infected => net_state_add_infected private  subroutine net_state_add_infected(this, net, node_id) Arguments Type Intent Optional Attributes Name class( net_state_t ) :: this type( network_t ), intent(in) :: net integer(kind=i4), intent(in) :: node_id procedure, public :: remove_infected => net_state_remove_infected private  subroutine net_state_remove_infected(this, net, node_id, node_pos, new_state) Arguments Type Intent Optional Attributes Name class( net_state_t ) :: this type( network_t ), intent(in) :: net integer(kind=i4), intent(in) :: node_id integer(kind=i4), intent(in) :: node_pos integer(kind=i2), intent(in) :: new_state procedure, public :: dynamics_init => net_state_dynamics_init private  subroutine net_state_dynamics_init(this, net) Arguments Type Intent Optional Attributes Name class( net_state_t ) :: this class( network_t ), intent(in) :: net procedure, public :: dynamics_update_dt => net_state_dynamics_update_dt private  function net_state_dynamics_update_dt(this, net, gen) result(res) Arguments Type Intent Optional Attributes Name class( net_state_t ) :: this class( network_t ), intent(in) :: net type(rndgen) :: gen Return Value logical procedure, public :: dynamics_step => net_state_dynamics_step private  subroutine net_state_dynamics_step(this, net, gen) Arguments Type Intent Optional Attributes Name class( net_state_t ) :: this class( network_t ), intent(in) :: net type(rndgen) :: gen procedure, public :: calculate_rates => net_state_calculate_rates private  subroutine net_state_calculate_rates(this, net) Arguments Type Intent Optional Attributes Name class( net_state_t ) :: this class( network_t ), intent(in) :: net procedure, public :: print_debug_quantities => net_state_print_debug_quantities private  subroutine net_state_print_debug_quantities(this) Arguments Type Intent Optional Attributes Name class( net_state_t ) :: this procedure, public :: activate_edge => net_state_activate_edge private  subroutine net_state_activate_edge(this, net, edge_id, edge_order) Arguments Type Intent Optional Attributes Name class( net_state_t ) :: this class( network_t ), intent(in) :: net integer(kind=i4), intent(in) :: edge_id integer(kind=i4), intent(in) :: edge_order procedure, public :: export_edges_states => net_state_export_edges_states private  subroutine net_state_export_edges_states(this, net, filename) Arguments Type Intent Optional Attributes Name class( net_state_t ) :: this type( network_t ), intent(in) :: net character(len=*), intent(in) :: filename procedure, public :: get_num_infected => net_state_get_num_infected private  function net_state_get_num_infected(this) result(n) Arguments Type Intent Optional Attributes Name class( net_state_t ), intent(in) :: this Return Value integer(kind=i4)","tags":"","url":"type/net_state_t~2.html"},{"title":"state_compartment_base_t – HyperSIS ","text":"type, public, abstract :: state_compartment_base_t Inherits type~~state_compartment_base_t~~InheritsGraph type~state_compartment_base_t state_compartment_base_t dynamical_list_t dynamical_list_t type~state_compartment_base_t->dynamical_list_t nodes Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~state_compartment_base_t~~InheritedByGraph type~state_compartment_base_t state_compartment_base_t type~state_compartment_t state_compartment_t type~state_compartment_t->type~state_compartment_base_t type~state_compartment_t~2 state_compartment_t type~state_compartment_t~2->type~state_compartment_base_t type~net_state_t net_state_t type~net_state_t->type~state_compartment_t infected type~net_state_t~2 net_state_t type~net_state_t~2->type~state_compartment_t~2 infected Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer(kind=i4), public :: num_nodes type(dynamical_list_t), public :: nodes logical, public, allocatable :: is_edge_active (:)","tags":"","url":"type/state_compartment_base_t.html"},{"title":"dyn_parameters_t – HyperSIS ","text":"type, public :: dyn_parameters_t Inherited by type~~dyn_parameters_t~~InheritedByGraph type~dyn_parameters_t dyn_parameters_t type~net_state_base_t net_state_base_t type~net_state_base_t->type~dyn_parameters_t params type~net_state_t net_state_t type~net_state_t->type~net_state_base_t type~net_state_t~2 net_state_t type~net_state_t~2->type~net_state_base_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial real(kind=dp), public :: alpha real(kind=dp), public, allocatable, dimension(:) :: beta integer(kind=i4), public, allocatable, dimension(:) :: theta real(kind=dp), public :: beta_scale Type-Bound Procedures procedure, public :: init => dyn_parameters_init private  subroutine dyn_parameters_init(this, net) Arguments Type Intent Optional Attributes Name class( dyn_parameters_t ) :: this type( network_t ) :: net procedure, public :: max_num_susceptible => dyn_parameters_max_num_susceptible private  function dyn_parameters_max_num_susceptible(this, edge_order) result(res) Arguments Type Intent Optional Attributes Name class( dyn_parameters_t ) :: this integer(kind=i4), intent(in) :: edge_order Return Value integer(kind=i4)","tags":"","url":"type/dyn_parameters_t.html"},{"title":"net_state_base_t – HyperSIS ","text":"type, public, abstract :: net_state_base_t Inherits type~~net_state_base_t~~InheritsGraph type~net_state_base_t net_state_base_t type~dyn_parameters_t dyn_parameters_t type~net_state_base_t->type~dyn_parameters_t params Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~net_state_base_t~~InheritedByGraph type~net_state_base_t net_state_base_t type~net_state_t net_state_t type~net_state_t->type~net_state_base_t type~net_state_t~2 net_state_t type~net_state_t~2->type~net_state_base_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer(kind=i2), public, allocatable, dimension(:) :: node_state type( dyn_parameters_t ), public :: params real(kind=dp), public :: time real(kind=dp), public :: total_rate real(kind=dp), public :: dt Type-Bound Procedures procedure(net_state_base_init), public, deferred :: init subroutine net_state_base_init(this, net, params, sampler_choice) Prototype Arguments Type Intent Optional Attributes Name class( net_state_base_t ) :: this type( network_t ), intent(in) :: net class( dyn_parameters_t ), intent(in) :: params character(len=*), intent(in) :: sampler_choice procedure(net_state_base_add_infected), public, deferred :: add_infected subroutine net_state_base_add_infected(this, net, node_id) Prototype Arguments Type Intent Optional Attributes Name class( net_state_base_t ) :: this type( network_t ), intent(in) :: net integer(kind=i4), intent(in) :: node_id procedure(net_state_base_remove_infected), public, deferred :: remove_infected subroutine net_state_base_remove_infected(this, net, node_id, node_pos, new_state) Prototype Arguments Type Intent Optional Attributes Name class( net_state_base_t ) :: this type( network_t ), intent(in) :: net integer(kind=i4), intent(in) :: node_id integer(kind=i4), intent(in) :: node_pos integer(kind=i2), intent(in) :: new_state procedure(net_state_base_dynamics_init), public, deferred :: dynamics_init subroutine net_state_base_dynamics_init(this, net) Prototype Arguments Type Intent Optional Attributes Name class( net_state_base_t ) :: this class( network_t ), intent(in) :: net procedure(net_state_base_dynamics_update_dt), public, deferred :: dynamics_update_dt function net_state_base_dynamics_update_dt(this, net, gen) result(res) Prototype Arguments Type Intent Optional Attributes Name class( net_state_base_t ) :: this class( network_t ), intent(in) :: net type(rndgen) :: gen Return Value logical procedure, public :: just_update_dt => dynamics_just_update_dt private  subroutine dynamics_just_update_dt(this, net, gen) Arguments Type Intent Optional Attributes Name class( net_state_base_t ) :: this class( network_t ), intent(in) :: net type(rndgen) :: gen procedure(net_state_base_dynamics_step), public, deferred :: dynamics_step subroutine net_state_base_dynamics_step(this, net, gen) Prototype Arguments Type Intent Optional Attributes Name class( net_state_base_t ) :: this class( network_t ), intent(in) :: net type(rndgen) :: gen generic, public :: init_config => net_state_init_config_node, net_state_init_config_list_of_nodes, net_state_init_random_fraction_of_nodes private  subroutine net_state_init_config_node(this, net, params, sampler_choice, node_id) Arguments Type Intent Optional Attributes Name class( net_state_base_t ) :: this type( network_t ), intent(in) :: net class( dyn_parameters_t ), intent(in) :: params character(len=*), intent(in) :: sampler_choice integer(kind=i4), intent(in) :: node_id private  subroutine net_state_init_config_list_of_nodes(this, net, params, sampler_choice, nodes) Arguments Type Intent Optional Attributes Name class( net_state_base_t ) :: this type( network_t ), intent(in) :: net class( dyn_parameters_t ), intent(in) :: params character(len=*), intent(in) :: sampler_choice integer(kind=i4), intent(in) :: nodes (:) private  subroutine net_state_init_random_fraction_of_nodes(this, net, gen, params, sampler_choice, fraction) Arguments Type Intent Optional Attributes Name class( net_state_base_t ) :: this type( network_t ), intent(in) :: net type(rndgen), intent(in) :: gen class( dyn_parameters_t ), intent(in) :: params character(len=*), intent(in) :: sampler_choice real(kind=dp), intent(in) :: fraction procedure, public :: export_nodes_states => net_state_export_nodes_states private  subroutine net_state_export_nodes_states(this, net, filename) Arguments Type Intent Optional Attributes Name class( net_state_base_t ) :: this type( network_t ), intent(in) :: net character(len=*), intent(in) :: filename procedure(net_state_base_export_edges_states), public, deferred :: export_edges_states subroutine net_state_base_export_edges_states(this, net, filename) Prototype Arguments Type Intent Optional Attributes Name class( net_state_base_t ) :: this type( network_t ), intent(in) :: net character(len=*), intent(in) :: filename procedure(get_num_infected_interface), public, deferred :: get_num_infected function get_num_infected_interface(this) result(n) Prototype Arguments Type Intent Optional Attributes Name class( net_state_base_t ), intent(in) :: this Return Value integer(kind=i4)","tags":"","url":"type/net_state_base_t.html"},{"title":"net_state_t – HyperSIS ","text":"type, public, extends( net_state_base_t ) :: net_state_t Inherits type~~net_state_t~~InheritsGraph type~net_state_t net_state_t sampler_base_t sampler_base_t type~net_state_t->sampler_base_t infection_attempts_sampler type~net_state_base_t net_state_base_t type~net_state_t->type~net_state_base_t type~state_compartment_t state_compartment_t type~net_state_t->type~state_compartment_t infected type~dyn_parameters_t dyn_parameters_t type~net_state_base_t->type~dyn_parameters_t params type~state_compartment_base_t state_compartment_base_t type~state_compartment_t->type~state_compartment_base_t dynamical_list_t dynamical_list_t type~state_compartment_base_t->dynamical_list_t nodes Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer(kind=i2), public, allocatable, dimension(:) :: node_state type( dyn_parameters_t ), public :: params real(kind=dp), public :: time real(kind=dp), public :: total_rate real(kind=dp), public :: dt type(state_compartment_t), public :: infected real(kind=dp), public :: total_infection_attempt_rate real(kind=dp), public :: total_healing_rate class(sampler_base_t), public, allocatable :: infection_attempts_sampler Type-Bound Procedures procedure, public :: just_update_dt => dynamics_just_update_dt private  subroutine dynamics_just_update_dt(this, net, gen) Arguments Type Intent Optional Attributes Name class( net_state_base_t ) :: this class( network_t ), intent(in) :: net type(rndgen) :: gen generic, public :: init_config => net_state_init_config_node, net_state_init_config_list_of_nodes, net_state_init_random_fraction_of_nodes private  subroutine net_state_init_config_node(this, net, params, sampler_choice, node_id) Arguments Type Intent Optional Attributes Name class( net_state_base_t ) :: this type( network_t ), intent(in) :: net class( dyn_parameters_t ), intent(in) :: params character(len=*), intent(in) :: sampler_choice integer(kind=i4), intent(in) :: node_id private  subroutine net_state_init_config_list_of_nodes(this, net, params, sampler_choice, nodes) Arguments Type Intent Optional Attributes Name class( net_state_base_t ) :: this type( network_t ), intent(in) :: net class( dyn_parameters_t ), intent(in) :: params character(len=*), intent(in) :: sampler_choice integer(kind=i4), intent(in) :: nodes (:) private  subroutine net_state_init_random_fraction_of_nodes(this, net, gen, params, sampler_choice, fraction) Arguments Type Intent Optional Attributes Name class( net_state_base_t ) :: this type( network_t ), intent(in) :: net type(rndgen), intent(in) :: gen class( dyn_parameters_t ), intent(in) :: params character(len=*), intent(in) :: sampler_choice real(kind=dp), intent(in) :: fraction procedure, public :: export_nodes_states => net_state_export_nodes_states private  subroutine net_state_export_nodes_states(this, net, filename) Arguments Type Intent Optional Attributes Name class( net_state_base_t ) :: this type( network_t ), intent(in) :: net character(len=*), intent(in) :: filename procedure, public :: init => net_state_init private  subroutine net_state_init(this, net, params, sampler_choice) Arguments Type Intent Optional Attributes Name class( net_state_t ) :: this type( network_t ), intent(in) :: net class( dyn_parameters_t ), intent(in) :: params character(len=*), intent(in) :: sampler_choice procedure, public :: add_infected => net_state_add_infected private  subroutine net_state_add_infected(this, net, node_id) Arguments Type Intent Optional Attributes Name class( net_state_t ) :: this type( network_t ), intent(in) :: net integer(kind=i4), intent(in) :: node_id procedure, public :: remove_infected => net_state_remove_infected private  subroutine net_state_remove_infected(this, net, node_id, node_pos, new_state) Arguments Type Intent Optional Attributes Name class( net_state_t ) :: this type( network_t ), intent(in) :: net integer(kind=i4), intent(in) :: node_id integer(kind=i4), intent(in) :: node_pos integer(kind=i2), intent(in) :: new_state procedure, public :: dynamics_init => net_state_dynamics_init private  subroutine net_state_dynamics_init(this, net) Arguments Type Intent Optional Attributes Name class( net_state_t ) :: this class( network_t ), intent(in) :: net procedure, public :: dynamics_update_dt => net_state_dynamics_update_dt private  function net_state_dynamics_update_dt(this, net, gen) result(res) Arguments Type Intent Optional Attributes Name class( net_state_t ) :: this class( network_t ), intent(in) :: net type(rndgen) :: gen Return Value logical procedure, public :: dynamics_step => net_state_dynamics_step private  subroutine net_state_dynamics_step(this, net, gen) Arguments Type Intent Optional Attributes Name class( net_state_t ) :: this class( network_t ), intent(in) :: net type(rndgen) :: gen procedure, public :: calculate_rates => net_state_calculate_rates private  subroutine net_state_calculate_rates(this, net) Arguments Type Intent Optional Attributes Name class( net_state_t ) :: this class( network_t ), intent(in) :: net procedure, public :: print_debug_quantities => net_state_print_debug_quantities private  subroutine net_state_print_debug_quantities(this) Arguments Type Intent Optional Attributes Name class( net_state_t ) :: this procedure, public :: remove_possibly_active_edge => net_state_remove_possibly_active_edge_from_list private  subroutine net_state_remove_possibly_active_edge_from_list(this, edge_id, edge_order) Arguments Type Intent Optional Attributes Name class( net_state_t ) :: this integer(kind=i4), intent(in) :: edge_id integer(kind=i4), intent(in) :: edge_order procedure, public :: activate_edge => net_state_activate_edge private  subroutine net_state_activate_edge(this, edge_id, edge_order) Arguments Type Intent Optional Attributes Name class( net_state_t ) :: this integer(kind=i4), intent(in) :: edge_id integer(kind=i4), intent(in) :: edge_order procedure, public :: export_edges_states => net_state_export_edges_states private  subroutine net_state_export_edges_states(this, net, filename) Arguments Type Intent Optional Attributes Name class( net_state_t ) :: this type( network_t ), intent(in) :: net character(len=*), intent(in) :: filename procedure, public :: get_num_infected => net_state_get_num_infected private  function net_state_get_num_infected(this) result(n) Arguments Type Intent Optional Attributes Name class( net_state_t ), intent(in) :: this Return Value integer(kind=i4)","tags":"","url":"type/net_state_t.html"},{"title":"hyperedge_t – HyperSIS ","text":"type, public :: hyperedge_t Hyperedge object to represent a hyperedge in the network.\nIt contains an ID, order m, and list of m + 1 nodes belonging to the hyperedge. Inherited by type~~hyperedge_t~~InheritedByGraph type~hyperedge_t hyperedge_t type~network_t network_t type~network_t->type~hyperedge_t edges Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer(kind=i4), public :: order = -1 integer(kind=i4), public, allocatable :: nodes (:) integer(kind=i4), public, allocatable :: dual_edges (:)","tags":"","url":"type/hyperedge_t.html"},{"title":"node_t – HyperSIS ","text":"type, public :: node_t Node object to represent a node in the network.\nIt contains an ID, degree, and list of hyperedges that the node belongs to. Inherited by type~~node_t~~InheritedByGraph type~node_t node_t type~network_t network_t type~network_t->type~node_t nodes Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer(kind=i4), public :: degree = 0 integer(kind=i4), public, allocatable :: edges (:) integer(kind=i4), public, allocatable :: dual_nodes (:)","tags":"","url":"type/node_t.html"},{"title":"network_t – HyperSIS ","text":"type, public :: network_t Network object to represent the entire hypergraph.\nIt contains the number of nodes, number of edges, and arrays of nodes and edges objects. Inherits type~~network_t~~InheritsGraph type~network_t network_t fixed_list_t fixed_list_t type~network_t->fixed_list_t nodes_per_degree, edges_per_order type~hyperedge_t hyperedge_t type~network_t->type~hyperedge_t edges type~network_props_t network_props_t type~network_t->type~network_props_t props type~node_t node_t type~network_t->type~node_t nodes Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer(kind=i4), public :: num_nodes = 0 integer(kind=i4), public :: num_edges = 0 integer(kind=i4), public :: max_order = 0 type( node_t ), public, allocatable :: nodes (:) type( hyperedge_t ), public, allocatable :: edges (:) type(network_props_t), public :: props type(fixed_list_t), public, allocatable :: nodes_per_degree (:) type(fixed_list_t), public, allocatable :: edges_per_order (:) Finalization Procedures final :: network_finalizer private  subroutine network_finalizer(net) Arguments Type Intent Optional Attributes Name type( network_t ), intent(inout) :: net Type-Bound Procedures procedure, public :: init => network_init private  subroutine network_init(net, num_nodes, num_edges) Arguments Type Intent Optional Attributes Name class( network_t ) :: net integer(kind=i4), intent(in) :: num_nodes integer(kind=i4), intent(in) :: num_edges procedure, public :: build_edges_from_nodes => network_build_edges_from_nodes private  subroutine network_build_edges_from_nodes(net) Subroutine to build edges from nodes in the network.\nIt iterates over each node and assigns the corresponding edges to the hyperedges.\n@param net The network object containing the nodes and edges. Note This subroutine modifies the edges of the network based on the nodes' connections. Note The edges are built by iterating over each node and assigning the corresponding edges to the hyperedges. Note The last_edge_index array is used to keep track of the last index for each hyperedge. Arguments Type Intent Optional Attributes Name class( network_t ) :: net procedure, public :: build_nodes_from_edges => network_build_nodes_from_edges private  subroutine network_build_nodes_from_edges(net) Arguments Type Intent Optional Attributes Name class( network_t ) :: net procedure, public :: print_nodes_and_edges => network_print_nodes_and_edges private  subroutine network_print_nodes_and_edges(net) Arguments Type Intent Optional Attributes Name class( network_t ), intent(in) :: net procedure, public :: clear_null_edges => network_clear_null_edges private  subroutine network_clear_null_edges(net, min_order_input) Arguments Type Intent Optional Attributes Name class( network_t ), intent(inout) :: net integer(kind=i4), intent(in), optional :: min_order_input procedure, public :: check_topology_consistency => network_check_topology_consistency private  subroutine network_check_topology_consistency(net) Arguments Type Intent Optional Attributes Name class( network_t ), intent(inout) :: net procedure, public :: remove_invalid_nodes_and_edges => network_remove_invalid_nodes_and_edges private  subroutine network_remove_invalid_nodes_and_edges(net) Arguments Type Intent Optional Attributes Name class( network_t ), intent(inout) :: net procedure, public :: clear_and_check_all => network_clear_and_check_all private  subroutine network_clear_and_check_all(net, min_order) Arguments Type Intent Optional Attributes Name class( network_t ), intent(inout) :: net integer(kind=i4), intent(in), optional :: min_order procedure, public :: reset_props => network_reset_props private  subroutine network_reset_props(net) Arguments Type Intent Optional Attributes Name class( network_t ), intent(inout) :: net procedure, public :: destroy => network_destroy private  subroutine network_destroy(net) Arguments Type Intent Optional Attributes Name class( network_t ), intent(inout) :: net","tags":"","url":"type/network_t.html"},{"title":"net_state_choose – HyperSIS","text":"public  subroutine net_state_choose(net_state, selected_algorithm) Uses hyperSIS_dynamics_NB_OGA_mod hyperSIS_dynamics_HB_OGA_mod proc~~net_state_choose~~UsesGraph proc~net_state_choose net_state_choose module~hypersis_dynamics_hb_oga_mod hyperSIS_dynamics_HB_OGA_mod proc~net_state_choose->module~hypersis_dynamics_hb_oga_mod module~hypersis_dynamics_nb_oga_mod hyperSIS_dynamics_NB_OGA_mod proc~net_state_choose->module~hypersis_dynamics_nb_oga_mod datastructs_mod datastructs_mod module~hypersis_dynamics_hb_oga_mod->datastructs_mod module~hypersis_dynamics_base_mod hyperSIS_dynamics_base_mod module~hypersis_dynamics_hb_oga_mod->module~hypersis_dynamics_base_mod module~hypersis_kinds_mod hyperSIS_kinds_mod module~hypersis_dynamics_hb_oga_mod->module~hypersis_kinds_mod module~hypersis_network_mod hyperSIS_network_mod module~hypersis_dynamics_hb_oga_mod->module~hypersis_network_mod module~hypersis_dynamics_nb_oga_mod->datastructs_mod module~hypersis_dynamics_nb_oga_mod->module~hypersis_dynamics_base_mod module~hypersis_dynamics_nb_oga_mod->module~hypersis_kinds_mod module~hypersis_dynamics_nb_oga_mod->module~hypersis_network_mod module~hypersis_dynamics_base_mod->datastructs_mod module~hypersis_dynamics_base_mod->module~hypersis_kinds_mod module~hypersis_dynamics_base_mod->module~hypersis_network_mod iso_fortran_env iso_fortran_env module~hypersis_kinds_mod->iso_fortran_env module~hypersis_network_mod->datastructs_mod module~hypersis_network_mod->module~hypersis_kinds_mod Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name class( net_state_base_t ), intent(out), allocatable :: net_state character(len=*), intent(in) :: selected_algorithm","tags":"","url":"proc/net_state_choose.html"},{"title":"network_import – HyperSIS","text":"public  subroutine network_import(net, filename, skip_check_consistency) Arguments Type Intent Optional Attributes Name class( network_t ), intent(inout) :: net character(len=*), intent(in) :: filename logical, optional :: skip_check_consistency Calls proc~~network_import~~CallsGraph proc~network_import network_import nodes nodes proc~network_import->nodes none~build_nodes_from_edges network_t%build_nodes_from_edges proc~network_import->none~build_nodes_from_edges none~check_topology_consistency network_t%check_topology_consistency proc~network_import->none~check_topology_consistency proc~count_integers_from_string count_integers_from_string proc~network_import->proc~count_integers_from_string log_write log_write none~check_topology_consistency->log_write Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~network_import~~CalledByGraph proc~network_import network_import proc~read_network read_network proc~read_network->proc~network_import Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/network_import.html"},{"title":"network_export – HyperSIS","text":"public  subroutine network_export(net, filename) Arguments Type Intent Optional Attributes Name class( network_t ), intent(in) :: net character(len=*), intent(in) :: filename","tags":"","url":"proc/network_export.html"},{"title":"network – HyperSIS","text":"public interface network Interface for the constructor of the network type. Module Procedures private  function network_new(num_nodes, num_edges) result(net) Constructor for the network type.\nIt initializes the number of nodes and edges, and allocates memory for the nodes and edges arrays.\n@param net The network object to be initialized.\n@param num_nodes The number of nodes in the network.\n@param num_edges The number of edges in the network. Note This subroutine allocates memory for the nodes and edges arrays based on the provided sizes. Note The arrays are allocated with the sizes specified by num_nodes and num_edges. Arguments Type Intent Optional Attributes Name integer(kind=i4), intent(in) :: num_nodes integer(kind=i4), intent(in) :: num_edges Return Value type( network_t )","tags":"","url":"interface/network.html"},{"title":"hyperedge – HyperSIS","text":"public interface hyperedge Interface for the constructor of the hyperedge type.\nIt receives the order OR a list of nodes and returns a new hyperedge object. Module Procedures private elemental function hyperedge_new(order) result(edge) Constructor for the hyperedge type.\nIt initializes the ID and order of the hyperedge, and allocates memory for the nodes array.\n@param order The order of the hyperedge. Note This subroutine allocates memory for the nodes array based on the provided size. Arguments Type Intent Optional Attributes Name integer(kind=i4), intent(in) :: order Return Value type( hyperedge_t ) private  function hyperedge_new_from_nodes_list(nodes) result(edge) Constructor for the hyperedge type from a list of nodes. Arguments Type Intent Optional Attributes Name integer(kind=i4), intent(in) :: nodes (:) Return Value type( hyperedge_t )","tags":"","url":"interface/hyperedge.html"},{"title":"count_integers_from_string – HyperSIS","text":"public  function count_integers_from_string(str) result(count) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value integer(kind=i4) Called by proc~~count_integers_from_string~~CalledByGraph proc~count_integers_from_string count_integers_from_string proc~network_import network_import proc~network_import->proc~count_integers_from_string proc~read_network read_network proc~read_network->proc~network_import Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/count_integers_from_string.html"},{"title":"swap – HyperSIS","text":"public interface swap Interface for the swap subroutine. Module Procedures private  subroutine swap_int(a, b) Arguments Type Intent Optional Attributes Name integer(kind=i4), intent(inout) :: a integer(kind=i4), intent(inout) :: b private  subroutine swap_real(a, b) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: a real(kind=dp), intent(inout) :: b","tags":"","url":"interface/swap.html"},{"title":"get_path_prefix – HyperSIS","text":"public  function get_path_prefix(tmp_prefix, remove_files) result(prefix) Build the prefix and remove old files Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: tmp_prefix logical, intent(in) :: remove_files Return Value character(len=:), allocatable","tags":"","url":"proc/get_path_prefix.html"},{"title":"check_export_nodes_and_edges_state – HyperSIS","text":"public  subroutine check_export_nodes_and_edges_state(export_states, input_export_states) Arguments Type Intent Optional Attributes Name procedure( proc_export_states ), pointer :: export_states logical, intent(in) :: input_export_states","tags":"","url":"proc/check_export_nodes_and_edges_state.html"},{"title":"check_qs_method – HyperSIS","text":"public  subroutine check_qs_method(after_dynamics_step, input_use_qs) Check which method to use after dynamics step Arguments Type Intent Optional Attributes Name procedure( proc_net_state_gen ), pointer :: after_dynamics_step logical, intent(in) :: input_use_qs","tags":"","url":"proc/check_qs_method.html"},{"title":"set_dyn_params – HyperSIS","text":"public  subroutine set_dyn_params(net, dyn_params, par_b, par_theta) Arguments Type Intent Optional Attributes Name class( network_t ), intent(in) :: net type( dyn_parameters_t ), intent(inout) :: dyn_params real(kind=dp), intent(in) :: par_b real(kind=dp), intent(in) :: par_theta Calls proc~~set_dyn_params~~CallsGraph proc~set_dyn_params set_dyn_params none~init~2 dyn_parameters_t%init proc~set_dyn_params->none~init~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/set_dyn_params.html"},{"title":"read_network – HyperSIS","text":"public  subroutine read_network(net, edges_filename) Arguments Type Intent Optional Attributes Name type( network_t ), intent(inout) :: net character(len=*), intent(in) :: edges_filename Calls proc~~read_network~~CallsGraph proc~read_network read_network proc~network_import network_import proc~read_network->proc~network_import nodes nodes proc~network_import->nodes none~build_nodes_from_edges network_t%build_nodes_from_edges proc~network_import->none~build_nodes_from_edges none~check_topology_consistency network_t%check_topology_consistency proc~network_import->none~check_topology_consistency proc~count_integers_from_string count_integers_from_string proc~network_import->proc~count_integers_from_string log_write log_write none~check_topology_consistency->log_write Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","url":"proc/read_network.html"},{"title":"set_initial_number_of_infected_nodes – HyperSIS","text":"public  subroutine set_initial_number_of_infected_nodes(net, inf_fraction, initial_number) Arguments Type Intent Optional Attributes Name class( network_t ), intent(in) :: net real(kind=dp), intent(inout) :: inf_fraction integer(kind=i4), intent(inout) :: initial_number","tags":"","url":"proc/set_initial_number_of_infected_nodes.html"},{"title":"proc_net_state_gen – HyperSIS","text":"interface public  subroutine proc_net_state_gen(net, state, gen) Arguments Type Intent Optional Attributes Name class( network_t ), intent(in) :: net class( net_state_base_t ), intent(inout) :: state class(rndgen), intent(inout) :: gen","tags":"","url":"interface/proc_net_state_gen.html"},{"title":"proc_export_states – HyperSIS","text":"interface public  subroutine proc_export_states(net, state, nodes_filename, edges_filename) Arguments Type Intent Optional Attributes Name class( network_t ), intent(in) :: net class( net_state_base_t ), intent(inout) :: state character(len=*), intent(in) :: nodes_filename character(len=*), intent(in) :: edges_filename","tags":"","url":"interface/proc_export_states.html"},{"title":"hyperSIS_dynamics_chooser_mod – HyperSIS","text":"Uses hyperSIS_dynamics_base_mod hyperSIS_kinds_mod module~~hypersis_dynamics_chooser_mod~~UsesGraph module~hypersis_dynamics_chooser_mod hyperSIS_dynamics_chooser_mod module~hypersis_dynamics_base_mod hyperSIS_dynamics_base_mod module~hypersis_dynamics_chooser_mod->module~hypersis_dynamics_base_mod module~hypersis_kinds_mod hyperSIS_kinds_mod module~hypersis_dynamics_chooser_mod->module~hypersis_kinds_mod module~hypersis_dynamics_base_mod->module~hypersis_kinds_mod datastructs_mod datastructs_mod module~hypersis_dynamics_base_mod->datastructs_mod module~hypersis_network_mod hyperSIS_network_mod module~hypersis_dynamics_base_mod->module~hypersis_network_mod iso_fortran_env iso_fortran_env module~hypersis_kinds_mod->iso_fortran_env module~hypersis_network_mod->module~hypersis_kinds_mod module~hypersis_network_mod->datastructs_mod Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~hypersis_dynamics_chooser_mod~~UsedByGraph module~hypersis_dynamics_chooser_mod hyperSIS_dynamics_chooser_mod module~hypersis_dynamics_mod hyperSIS_dynamics_mod module~hypersis_dynamics_mod->module~hypersis_dynamics_chooser_mod module~hypersis_program_common_mod hyperSIS_program_common_mod module~hypersis_program_common_mod->module~hypersis_dynamics_mod Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: alg_choices = 'HB_OGA,NB_OGA' Subroutines public  subroutine net_state_choose (net_state, selected_algorithm) Arguments Type Intent Optional Attributes Name class( net_state_base_t ), intent(out), allocatable :: net_state character(len=*), intent(in) :: selected_algorithm","tags":"","url":"module/hypersis_dynamics_chooser_mod.html"},{"title":"hyperSIS_dynamics_NB_OGA_mod – HyperSIS","text":"Uses hyperSIS_network_mod datastructs_mod hyperSIS_kinds_mod hyperSIS_dynamics_base_mod module~~hypersis_dynamics_nb_oga_mod~~UsesGraph module~hypersis_dynamics_nb_oga_mod hyperSIS_dynamics_NB_OGA_mod datastructs_mod datastructs_mod module~hypersis_dynamics_nb_oga_mod->datastructs_mod module~hypersis_dynamics_base_mod hyperSIS_dynamics_base_mod module~hypersis_dynamics_nb_oga_mod->module~hypersis_dynamics_base_mod module~hypersis_kinds_mod hyperSIS_kinds_mod module~hypersis_dynamics_nb_oga_mod->module~hypersis_kinds_mod module~hypersis_network_mod hyperSIS_network_mod module~hypersis_dynamics_nb_oga_mod->module~hypersis_network_mod module~hypersis_dynamics_base_mod->datastructs_mod module~hypersis_dynamics_base_mod->module~hypersis_kinds_mod module~hypersis_dynamics_base_mod->module~hypersis_network_mod iso_fortran_env iso_fortran_env module~hypersis_kinds_mod->iso_fortran_env module~hypersis_network_mod->datastructs_mod module~hypersis_network_mod->module~hypersis_kinds_mod Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~hypersis_dynamics_nb_oga_mod~~UsedByGraph module~hypersis_dynamics_nb_oga_mod hyperSIS_dynamics_NB_OGA_mod proc~net_state_choose net_state_choose proc~net_state_choose->module~hypersis_dynamics_nb_oga_mod Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public, extends( net_state_base_t ) :: net_state_t Components Type Visibility Attributes Name Initial integer(kind=i2), public, allocatable, dimension(:) :: node_state type( dyn_parameters_t ), public :: params real(kind=dp), public :: time real(kind=dp), public :: total_rate real(kind=dp), public :: dt type(state_compartment_t), public :: infected real(kind=dp), public :: total_infection_attempt_rate real(kind=dp), public :: total_healing_rate class(sampler_base_t), public, allocatable :: possibly_quiescent_nodes_sampler Type-Bound Procedures procedure, public :: just_update_dt => dynamics_just_update_dt generic, public :: init_config => net_state_init_config_node, net_state_init_config_list_of_nodes, net_state_init_random_fraction_of_nodes procedure, public :: export_nodes_states => net_state_export_nodes_states procedure, public :: init => net_state_init procedure, public :: add_infected => net_state_add_infected procedure, public :: remove_infected => net_state_remove_infected procedure, public :: dynamics_init => net_state_dynamics_init procedure, public :: dynamics_update_dt => net_state_dynamics_update_dt procedure, public :: dynamics_step => net_state_dynamics_step procedure, public :: calculate_rates => net_state_calculate_rates procedure, public :: print_debug_quantities => net_state_print_debug_quantities procedure, public :: activate_edge => net_state_activate_edge procedure, public :: export_edges_states => net_state_export_edges_states procedure, public :: get_num_infected => net_state_get_num_infected","tags":"","url":"module/hypersis_dynamics_nb_oga_mod.html"},{"title":"hyperSIS_dynamics_base_mod – HyperSIS","text":"Uses hyperSIS_network_mod datastructs_mod hyperSIS_kinds_mod module~~hypersis_dynamics_base_mod~~UsesGraph module~hypersis_dynamics_base_mod hyperSIS_dynamics_base_mod datastructs_mod datastructs_mod module~hypersis_dynamics_base_mod->datastructs_mod module~hypersis_kinds_mod hyperSIS_kinds_mod module~hypersis_dynamics_base_mod->module~hypersis_kinds_mod module~hypersis_network_mod hyperSIS_network_mod module~hypersis_dynamics_base_mod->module~hypersis_network_mod iso_fortran_env iso_fortran_env module~hypersis_kinds_mod->iso_fortran_env module~hypersis_network_mod->datastructs_mod module~hypersis_network_mod->module~hypersis_kinds_mod Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~hypersis_dynamics_base_mod~~UsedByGraph module~hypersis_dynamics_base_mod hyperSIS_dynamics_base_mod module~hypersis_dynamics_chooser_mod hyperSIS_dynamics_chooser_mod module~hypersis_dynamics_chooser_mod->module~hypersis_dynamics_base_mod module~hypersis_dynamics_hb_oga_mod hyperSIS_dynamics_HB_OGA_mod module~hypersis_dynamics_hb_oga_mod->module~hypersis_dynamics_base_mod module~hypersis_dynamics_mod hyperSIS_dynamics_mod module~hypersis_dynamics_mod->module~hypersis_dynamics_base_mod module~hypersis_dynamics_mod->module~hypersis_dynamics_chooser_mod module~hypersis_dynamics_nb_oga_mod hyperSIS_dynamics_NB_OGA_mod module~hypersis_dynamics_nb_oga_mod->module~hypersis_dynamics_base_mod module~hypersis_program_common_mod hyperSIS_program_common_mod module~hypersis_program_common_mod->module~hypersis_dynamics_mod proc~net_state_choose net_state_choose proc~net_state_choose->module~hypersis_dynamics_hb_oga_mod proc~net_state_choose->module~hypersis_dynamics_nb_oga_mod Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public, abstract :: state_compartment_base_t Components Type Visibility Attributes Name Initial integer(kind=i4), public :: num_nodes type(dynamical_list_t), public :: nodes logical, public, allocatable :: is_edge_active (:) type, public :: dyn_parameters_t Components Type Visibility Attributes Name Initial real(kind=dp), public :: alpha real(kind=dp), public, allocatable, dimension(:) :: beta integer(kind=i4), public, allocatable, dimension(:) :: theta real(kind=dp), public :: beta_scale Type-Bound Procedures procedure, public :: init => dyn_parameters_init procedure, public :: max_num_susceptible => dyn_parameters_max_num_susceptible type, public, abstract :: net_state_base_t Components Type Visibility Attributes Name Initial integer(kind=i2), public, allocatable, dimension(:) :: node_state type( dyn_parameters_t ), public :: params real(kind=dp), public :: time real(kind=dp), public :: total_rate real(kind=dp), public :: dt Type-Bound Procedures procedure(net_state_base_init), public, deferred :: init procedure(net_state_base_add_infected), public, deferred :: add_infected procedure(net_state_base_remove_infected), public, deferred :: remove_infected procedure(net_state_base_dynamics_init), public, deferred :: dynamics_init procedure(net_state_base_dynamics_update_dt), public, deferred :: dynamics_update_dt procedure, public :: just_update_dt => dynamics_just_update_dt procedure(net_state_base_dynamics_step), public, deferred :: dynamics_step generic, public :: init_config => net_state_init_config_node, net_state_init_config_list_of_nodes, net_state_init_random_fraction_of_nodes procedure, public :: export_nodes_states => net_state_export_nodes_states procedure(net_state_base_export_edges_states), public, deferred :: export_edges_states procedure(get_num_infected_interface), public, deferred :: get_num_infected","tags":"","url":"module/hypersis_dynamics_base_mod.html"},{"title":"hyperSIS_dynamics_mod – HyperSIS","text":"Uses hyperSIS_dynamics_base_mod hyperSIS_dynamics_chooser_mod module~~hypersis_dynamics_mod~~UsesGraph module~hypersis_dynamics_mod hyperSIS_dynamics_mod module~hypersis_dynamics_base_mod hyperSIS_dynamics_base_mod module~hypersis_dynamics_mod->module~hypersis_dynamics_base_mod module~hypersis_dynamics_chooser_mod hyperSIS_dynamics_chooser_mod module~hypersis_dynamics_mod->module~hypersis_dynamics_chooser_mod datastructs_mod datastructs_mod module~hypersis_dynamics_base_mod->datastructs_mod module~hypersis_kinds_mod hyperSIS_kinds_mod module~hypersis_dynamics_base_mod->module~hypersis_kinds_mod module~hypersis_network_mod hyperSIS_network_mod module~hypersis_dynamics_base_mod->module~hypersis_network_mod module~hypersis_dynamics_chooser_mod->module~hypersis_dynamics_base_mod module~hypersis_dynamics_chooser_mod->module~hypersis_kinds_mod iso_fortran_env iso_fortran_env module~hypersis_kinds_mod->iso_fortran_env module~hypersis_network_mod->datastructs_mod module~hypersis_network_mod->module~hypersis_kinds_mod Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~hypersis_dynamics_mod~~UsedByGraph module~hypersis_dynamics_mod hyperSIS_dynamics_mod module~hypersis_program_common_mod hyperSIS_program_common_mod module~hypersis_program_common_mod->module~hypersis_dynamics_mod Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses.","tags":"","url":"module/hypersis_dynamics_mod.html"},{"title":"hyperSIS_dynamics_HB_OGA_mod – HyperSIS","text":"Uses hyperSIS_network_mod datastructs_mod hyperSIS_kinds_mod hyperSIS_dynamics_base_mod module~~hypersis_dynamics_hb_oga_mod~~UsesGraph module~hypersis_dynamics_hb_oga_mod hyperSIS_dynamics_HB_OGA_mod datastructs_mod datastructs_mod module~hypersis_dynamics_hb_oga_mod->datastructs_mod module~hypersis_dynamics_base_mod hyperSIS_dynamics_base_mod module~hypersis_dynamics_hb_oga_mod->module~hypersis_dynamics_base_mod module~hypersis_kinds_mod hyperSIS_kinds_mod module~hypersis_dynamics_hb_oga_mod->module~hypersis_kinds_mod module~hypersis_network_mod hyperSIS_network_mod module~hypersis_dynamics_hb_oga_mod->module~hypersis_network_mod module~hypersis_dynamics_base_mod->datastructs_mod module~hypersis_dynamics_base_mod->module~hypersis_kinds_mod module~hypersis_dynamics_base_mod->module~hypersis_network_mod iso_fortran_env iso_fortran_env module~hypersis_kinds_mod->iso_fortran_env module~hypersis_network_mod->datastructs_mod module~hypersis_network_mod->module~hypersis_kinds_mod Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~hypersis_dynamics_hb_oga_mod~~UsedByGraph module~hypersis_dynamics_hb_oga_mod hyperSIS_dynamics_HB_OGA_mod proc~net_state_choose net_state_choose proc~net_state_choose->module~hypersis_dynamics_hb_oga_mod Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public, extends( net_state_base_t ) :: net_state_t Components Type Visibility Attributes Name Initial integer(kind=i2), public, allocatable, dimension(:) :: node_state type( dyn_parameters_t ), public :: params real(kind=dp), public :: time real(kind=dp), public :: total_rate real(kind=dp), public :: dt type(state_compartment_t), public :: infected real(kind=dp), public :: total_infection_attempt_rate real(kind=dp), public :: total_healing_rate class(sampler_base_t), public, allocatable :: infection_attempts_sampler Type-Bound Procedures procedure, public :: just_update_dt => dynamics_just_update_dt generic, public :: init_config => net_state_init_config_node, net_state_init_config_list_of_nodes, net_state_init_random_fraction_of_nodes procedure, public :: export_nodes_states => net_state_export_nodes_states procedure, public :: init => net_state_init procedure, public :: add_infected => net_state_add_infected procedure, public :: remove_infected => net_state_remove_infected procedure, public :: dynamics_init => net_state_dynamics_init procedure, public :: dynamics_update_dt => net_state_dynamics_update_dt procedure, public :: dynamics_step => net_state_dynamics_step procedure, public :: calculate_rates => net_state_calculate_rates procedure, public :: print_debug_quantities => net_state_print_debug_quantities procedure, public :: remove_possibly_active_edge => net_state_remove_possibly_active_edge_from_list procedure, public :: activate_edge => net_state_activate_edge procedure, public :: export_edges_states => net_state_export_edges_states procedure, public :: get_num_infected => net_state_get_num_infected","tags":"","url":"module/hypersis_dynamics_hb_oga_mod.html"},{"title":"hyperSIS_network_io_mod – HyperSIS","text":"Uses hyperSIS_network_mod datastructs_mod hyperSIS_kinds_mod module~~hypersis_network_io_mod~~UsesGraph module~hypersis_network_io_mod hyperSIS_network_io_mod datastructs_mod datastructs_mod module~hypersis_network_io_mod->datastructs_mod module~hypersis_kinds_mod hyperSIS_kinds_mod module~hypersis_network_io_mod->module~hypersis_kinds_mod module~hypersis_network_mod hyperSIS_network_mod module~hypersis_network_io_mod->module~hypersis_network_mod iso_fortran_env iso_fortran_env module~hypersis_kinds_mod->iso_fortran_env module~hypersis_network_mod->datastructs_mod module~hypersis_network_mod->module~hypersis_kinds_mod Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~hypersis_network_io_mod~~UsedByGraph module~hypersis_network_io_mod hyperSIS_network_io_mod module~hypersis_program_common_mod hyperSIS_program_common_mod module~hypersis_program_common_mod->module~hypersis_network_io_mod Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine network_import (net, filename, skip_check_consistency) Arguments Type Intent Optional Attributes Name class( network_t ), intent(inout) :: net character(len=*), intent(in) :: filename logical, optional :: skip_check_consistency public  subroutine network_export (net, filename) Arguments Type Intent Optional Attributes Name class( network_t ), intent(in) :: net character(len=*), intent(in) :: filename","tags":"","url":"module/hypersis_network_io_mod.html"},{"title":"hyperSIS_network_mod – HyperSIS","text":"Uses datastructs_mod hyperSIS_kinds_mod module~~hypersis_network_mod~~UsesGraph module~hypersis_network_mod hyperSIS_network_mod datastructs_mod datastructs_mod module~hypersis_network_mod->datastructs_mod module~hypersis_kinds_mod hyperSIS_kinds_mod module~hypersis_network_mod->module~hypersis_kinds_mod iso_fortran_env iso_fortran_env module~hypersis_kinds_mod->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~hypersis_network_mod~~UsedByGraph module~hypersis_network_mod hyperSIS_network_mod module~hypersis_dynamics_base_mod hyperSIS_dynamics_base_mod module~hypersis_dynamics_base_mod->module~hypersis_network_mod module~hypersis_dynamics_hb_oga_mod hyperSIS_dynamics_HB_OGA_mod module~hypersis_dynamics_hb_oga_mod->module~hypersis_network_mod module~hypersis_dynamics_hb_oga_mod->module~hypersis_dynamics_base_mod module~hypersis_dynamics_nb_oga_mod hyperSIS_dynamics_NB_OGA_mod module~hypersis_dynamics_nb_oga_mod->module~hypersis_network_mod module~hypersis_dynamics_nb_oga_mod->module~hypersis_dynamics_base_mod module~hypersis_network_io_mod hyperSIS_network_io_mod module~hypersis_network_io_mod->module~hypersis_network_mod module~hypersis_program_common_mod hyperSIS_program_common_mod module~hypersis_program_common_mod->module~hypersis_network_mod module~hypersis_program_common_mod->module~hypersis_network_io_mod module~hypersis_dynamics_mod hyperSIS_dynamics_mod module~hypersis_program_common_mod->module~hypersis_dynamics_mod module~hypersis_dynamics_chooser_mod hyperSIS_dynamics_chooser_mod module~hypersis_dynamics_chooser_mod->module~hypersis_dynamics_base_mod module~hypersis_dynamics_mod->module~hypersis_dynamics_base_mod module~hypersis_dynamics_mod->module~hypersis_dynamics_chooser_mod proc~net_state_choose net_state_choose proc~net_state_choose->module~hypersis_dynamics_hb_oga_mod proc~net_state_choose->module~hypersis_dynamics_nb_oga_mod Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces public        interface network Interface for the constructor of the network type. private  function network_new(num_nodes, num_edges) result(net) Constructor for the network type.\nIt initializes the number of nodes and edges, and allocates memory for the nodes and edges arrays.\n@param net The network object to be initialized.\n@param num_nodes The number of nodes in the network.\n@param num_edges The number of edges in the network. Note This subroutine allocates memory for the nodes and edges arrays based on the provided sizes. Note The arrays are allocated with the sizes specified by num_nodes and num_edges. Arguments Type Intent Optional Attributes Name integer(kind=i4), intent(in) :: num_nodes integer(kind=i4), intent(in) :: num_edges Return Value type( network_t ) public        interface hyperedge Interface for the constructor of the hyperedge type.\nIt receives the order OR a list of nodes and returns a new hyperedge object. private elemental function hyperedge_new(order) result(edge) Constructor for the hyperedge type.\nIt initializes the ID and order of the hyperedge, and allocates memory for the nodes array.\n@param order The order of the hyperedge. Note This subroutine allocates memory for the nodes array based on the provided size. Arguments Type Intent Optional Attributes Name integer(kind=i4), intent(in) :: order Return Value type( hyperedge_t ) private  function hyperedge_new_from_nodes_list(nodes) result(edge) Constructor for the hyperedge type from a list of nodes. Arguments Type Intent Optional Attributes Name integer(kind=i4), intent(in) :: nodes (:) Return Value type( hyperedge_t ) Derived Types type, public :: hyperedge_t Hyperedge object to represent a hyperedge in the network.\nIt contains an ID, order m, and list of m + 1 nodes belonging to the hyperedge. Components Type Visibility Attributes Name Initial integer(kind=i4), public :: order = -1 integer(kind=i4), public, allocatable :: nodes (:) integer(kind=i4), public, allocatable :: dual_edges (:) type, public :: node_t Node object to represent a node in the network.\nIt contains an ID, degree, and list of hyperedges that the node belongs to. Components Type Visibility Attributes Name Initial integer(kind=i4), public :: degree = 0 integer(kind=i4), public, allocatable :: edges (:) integer(kind=i4), public, allocatable :: dual_nodes (:) type, public :: network_t Network object to represent the entire hypergraph.\nIt contains the number of nodes, number of edges, and arrays of nodes and edges objects. Components Type Visibility Attributes Name Initial integer(kind=i4), public :: num_nodes = 0 integer(kind=i4), public :: num_edges = 0 integer(kind=i4), public :: max_order = 0 type( node_t ), public, allocatable :: nodes (:) type( hyperedge_t ), public, allocatable :: edges (:) type(network_props_t), public :: props type(fixed_list_t), public, allocatable :: nodes_per_degree (:) type(fixed_list_t), public, allocatable :: edges_per_order (:) Finalizations Procedures final :: network_finalizer Type-Bound Procedures procedure, public :: init => network_init procedure, public :: build_edges_from_nodes => network_build_edges_from_nodes procedure, public :: build_nodes_from_edges => network_build_nodes_from_edges procedure, public :: print_nodes_and_edges => network_print_nodes_and_edges procedure, public :: clear_null_edges => network_clear_null_edges procedure, public :: check_topology_consistency => network_check_topology_consistency procedure, public :: remove_invalid_nodes_and_edges => network_remove_invalid_nodes_and_edges procedure, public :: clear_and_check_all => network_clear_and_check_all procedure, public :: reset_props => network_reset_props procedure, public :: destroy => network_destroy","tags":"","url":"module/hypersis_network_mod.html"},{"title":"hyperSIS_kinds_mod – HyperSIS","text":"Uses iso_fortran_env module~~hypersis_kinds_mod~~UsesGraph module~hypersis_kinds_mod hyperSIS_kinds_mod iso_fortran_env iso_fortran_env module~hypersis_kinds_mod->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~hypersis_kinds_mod~~UsedByGraph module~hypersis_kinds_mod hyperSIS_kinds_mod module~hypersis_dynamics_base_mod hyperSIS_dynamics_base_mod module~hypersis_dynamics_base_mod->module~hypersis_kinds_mod module~hypersis_network_mod hyperSIS_network_mod module~hypersis_dynamics_base_mod->module~hypersis_network_mod module~hypersis_dynamics_chooser_mod hyperSIS_dynamics_chooser_mod module~hypersis_dynamics_chooser_mod->module~hypersis_kinds_mod module~hypersis_dynamics_chooser_mod->module~hypersis_dynamics_base_mod module~hypersis_dynamics_hb_oga_mod hyperSIS_dynamics_HB_OGA_mod module~hypersis_dynamics_hb_oga_mod->module~hypersis_kinds_mod module~hypersis_dynamics_hb_oga_mod->module~hypersis_dynamics_base_mod module~hypersis_dynamics_hb_oga_mod->module~hypersis_network_mod module~hypersis_dynamics_nb_oga_mod hyperSIS_dynamics_NB_OGA_mod module~hypersis_dynamics_nb_oga_mod->module~hypersis_kinds_mod module~hypersis_dynamics_nb_oga_mod->module~hypersis_dynamics_base_mod module~hypersis_dynamics_nb_oga_mod->module~hypersis_network_mod module~hypersis_network_io_mod hyperSIS_network_io_mod module~hypersis_network_io_mod->module~hypersis_kinds_mod module~hypersis_network_io_mod->module~hypersis_network_mod module~hypersis_network_mod->module~hypersis_kinds_mod module~hypersis_program_common_mod hyperSIS_program_common_mod module~hypersis_program_common_mod->module~hypersis_kinds_mod module~hypersis_program_common_mod->module~hypersis_network_io_mod module~hypersis_program_common_mod->module~hypersis_network_mod module~hypersis_dynamics_mod hyperSIS_dynamics_mod module~hypersis_program_common_mod->module~hypersis_dynamics_mod module~hypersis_dynamics_mod->module~hypersis_dynamics_base_mod module~hypersis_dynamics_mod->module~hypersis_dynamics_chooser_mod proc~net_state_choose net_state_choose proc~net_state_choose->module~hypersis_dynamics_hb_oga_mod proc~net_state_choose->module~hypersis_dynamics_nb_oga_mod Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: fmt_general = '(*(g0,x))' character(len=*), public, parameter :: fmt_comma = '(*(g0,\",\"))' Interfaces public        interface swap Interface for the swap subroutine. private  subroutine swap_int(a, b) Arguments Type Intent Optional Attributes Name integer(kind=i4), intent(inout) :: a integer(kind=i4), intent(inout) :: b private  subroutine swap_real(a, b) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: a real(kind=dp), intent(inout) :: b Functions public  function count_integers_from_string (str) result(count) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value integer(kind=i4)","tags":"","url":"module/hypersis_kinds_mod.html"},{"title":"hyperSIS_program_common_mod – HyperSIS","text":"Uses hyperSIS_network_mod hyperSIS_network_io_mod rndgen_mod hyperSIS_dynamics_mod hyperSIS_kinds_mod module~~hypersis_program_common_mod~~UsesGraph module~hypersis_program_common_mod hyperSIS_program_common_mod module~hypersis_dynamics_mod hyperSIS_dynamics_mod module~hypersis_program_common_mod->module~hypersis_dynamics_mod module~hypersis_kinds_mod hyperSIS_kinds_mod module~hypersis_program_common_mod->module~hypersis_kinds_mod module~hypersis_network_io_mod hyperSIS_network_io_mod module~hypersis_program_common_mod->module~hypersis_network_io_mod module~hypersis_network_mod hyperSIS_network_mod module~hypersis_program_common_mod->module~hypersis_network_mod rndgen_mod rndgen_mod module~hypersis_program_common_mod->rndgen_mod module~hypersis_dynamics_base_mod hyperSIS_dynamics_base_mod module~hypersis_dynamics_mod->module~hypersis_dynamics_base_mod module~hypersis_dynamics_chooser_mod hyperSIS_dynamics_chooser_mod module~hypersis_dynamics_mod->module~hypersis_dynamics_chooser_mod iso_fortran_env iso_fortran_env module~hypersis_kinds_mod->iso_fortran_env module~hypersis_network_io_mod->module~hypersis_kinds_mod module~hypersis_network_io_mod->module~hypersis_network_mod datastructs_mod datastructs_mod module~hypersis_network_io_mod->datastructs_mod module~hypersis_network_mod->module~hypersis_kinds_mod module~hypersis_network_mod->datastructs_mod module~hypersis_dynamics_base_mod->module~hypersis_kinds_mod module~hypersis_dynamics_base_mod->module~hypersis_network_mod module~hypersis_dynamics_base_mod->datastructs_mod module~hypersis_dynamics_chooser_mod->module~hypersis_kinds_mod module~hypersis_dynamics_chooser_mod->module~hypersis_dynamics_base_mod Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces interface public  subroutine proc_net_state_gen(net, state, gen) Arguments Type Intent Optional Attributes Name class( network_t ), intent(in) :: net class( net_state_base_t ), intent(inout) :: state class(rndgen), intent(inout) :: gen interface public  subroutine proc_export_states(net, state, nodes_filename, edges_filename) Arguments Type Intent Optional Attributes Name class( network_t ), intent(in) :: net class( net_state_base_t ), intent(inout) :: state character(len=*), intent(in) :: nodes_filename character(len=*), intent(in) :: edges_filename Functions public  function get_path_prefix (tmp_prefix, remove_files) result(prefix) Build the prefix and remove old files Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: tmp_prefix logical, intent(in) :: remove_files Return Value character(len=:), allocatable Subroutines public  subroutine check_export_nodes_and_edges_state (export_states, input_export_states) Arguments Type Intent Optional Attributes Name procedure( proc_export_states ), pointer :: export_states logical, intent(in) :: input_export_states public  subroutine check_qs_method (after_dynamics_step, input_use_qs) Check which method to use after dynamics step Arguments Type Intent Optional Attributes Name procedure( proc_net_state_gen ), pointer :: after_dynamics_step logical, intent(in) :: input_use_qs public  subroutine set_dyn_params (net, dyn_params, par_b, par_theta) Arguments Type Intent Optional Attributes Name class( network_t ), intent(in) :: net type( dyn_parameters_t ), intent(inout) :: dyn_params real(kind=dp), intent(in) :: par_b real(kind=dp), intent(in) :: par_theta public  subroutine read_network (net, edges_filename) Arguments Type Intent Optional Attributes Name type( network_t ), intent(inout) :: net character(len=*), intent(in) :: edges_filename public  subroutine set_initial_number_of_infected_nodes (net, inf_fraction, initial_number) Arguments Type Intent Optional Attributes Name class( network_t ), intent(in) :: net real(kind=dp), intent(inout) :: inf_fraction integer(kind=i4), intent(inout) :: initial_number","tags":"","url":"module/hypersis_program_common_mod.html"},{"title":"dynamics_chooser.f90 – HyperSIS","text":"This file depends on sourcefile~~dynamics_chooser.f90~~EfferentGraph sourcefile~dynamics_chooser.f90 dynamics_chooser.f90 sourcefile~dynamics_base.f90 dynamics_base.f90 sourcefile~dynamics_chooser.f90->sourcefile~dynamics_base.f90 sourcefile~dynamics_hb_oga.f90 dynamics_HB_OGA.f90 sourcefile~dynamics_chooser.f90->sourcefile~dynamics_hb_oga.f90 sourcefile~dynamics_nb_oga.f90 dynamics_NB_OGA.f90 sourcefile~dynamics_chooser.f90->sourcefile~dynamics_nb_oga.f90 sourcefile~kinds.f90 kinds.f90 sourcefile~dynamics_chooser.f90->sourcefile~kinds.f90 sourcefile~dynamics_base.f90->sourcefile~kinds.f90 sourcefile~network.f90 network.f90 sourcefile~dynamics_base.f90->sourcefile~network.f90 sourcefile~dynamics_hb_oga.f90->sourcefile~dynamics_base.f90 sourcefile~dynamics_hb_oga.f90->sourcefile~kinds.f90 sourcefile~dynamics_hb_oga.f90->sourcefile~network.f90 sourcefile~dynamics_nb_oga.f90->sourcefile~dynamics_base.f90 sourcefile~dynamics_nb_oga.f90->sourcefile~kinds.f90 sourcefile~dynamics_nb_oga.f90->sourcefile~network.f90 sourcefile~network.f90->sourcefile~kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~dynamics_chooser.f90~~AfferentGraph sourcefile~dynamics_chooser.f90 dynamics_chooser.f90 sourcefile~dynamics.f90 dynamics.f90 sourcefile~dynamics.f90->sourcefile~dynamics_chooser.f90 sourcefile~common.f90 common.f90 sourcefile~common.f90->sourcefile~dynamics.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module hyperSIS_dynamics_chooser_mod use hyperSIS_kinds_mod use hyperSIS_dynamics_base_mod , only : net_state_base_t implicit none private character ( len =* ), parameter :: alg_choices = 'HB_OGA,NB_OGA' public :: net_state_choose , alg_choices contains subroutine net_state_choose ( net_state , selected_algorithm ) use hyperSIS_dynamics_HB_OGA_mod , only : HB_OGA_mod_net_state_t => net_state_t use hyperSIS_dynamics_NB_OGA_mod , only : NB_OGA_mod_net_state_t => net_state_t class ( net_state_base_t ), allocatable , intent ( out ) :: net_state character ( len =* ), intent ( in ) :: selected_algorithm select case ( trim ( adjustl ( selected_algorithm ))) case ( 'HB_OGA' ) allocate ( HB_OGA_mod_net_state_t :: net_state ) case ( 'NB_OGA' ) allocate ( NB_OGA_mod_net_state_t :: net_state ) case default error stop 'Unknown algorithm selected: ' // trim ( adjustl ( selected_algorithm )) end select end subroutine end module","tags":"","url":"sourcefile/dynamics_chooser.f90.html"},{"title":"dynamics_NB_OGA.f90 – HyperSIS","text":"This file depends on sourcefile~~dynamics_nb_oga.f90~~EfferentGraph sourcefile~dynamics_nb_oga.f90 dynamics_NB_OGA.f90 sourcefile~dynamics_base.f90 dynamics_base.f90 sourcefile~dynamics_nb_oga.f90->sourcefile~dynamics_base.f90 sourcefile~kinds.f90 kinds.f90 sourcefile~dynamics_nb_oga.f90->sourcefile~kinds.f90 sourcefile~network.f90 network.f90 sourcefile~dynamics_nb_oga.f90->sourcefile~network.f90 sourcefile~dynamics_base.f90->sourcefile~kinds.f90 sourcefile~dynamics_base.f90->sourcefile~network.f90 sourcefile~network.f90->sourcefile~kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~dynamics_nb_oga.f90~~AfferentGraph sourcefile~dynamics_nb_oga.f90 dynamics_NB_OGA.f90 sourcefile~dynamics_chooser.f90 dynamics_chooser.f90 sourcefile~dynamics_chooser.f90->sourcefile~dynamics_nb_oga.f90 sourcefile~dynamics.f90 dynamics.f90 sourcefile~dynamics.f90->sourcefile~dynamics_chooser.f90 sourcefile~common.f90 common.f90 sourcefile~common.f90->sourcefile~dynamics.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module hyperSIS_dynamics_NB_OGA_mod use hyperSIS_kinds_mod use hyperSIS_network_mod use hyperSIS_dynamics_base_mod use datastructs_mod , only : dynamical_list_t use datastructs_mod , only : sampler_base_t use datastructs_mod , only : choose_sampler use datastructs_mod , only : log_unit , log_write , LOGGER_OK , LOG_ERROR , LOG_WARNING , LOG_INFO , LOG_DEBUG implicit none private character ( len =* ), parameter :: ALGORITHM_NAME = 'NB_OGA' type , extends ( state_compartment_base_t ) :: state_compartment_t integer ( kind = i4 ), allocatable :: num_infected_nodes_per_edge (:) ! number of nodes in that state in that edge real ( kind = dp ), allocatable :: max_rate_per_node (:) ! maximum rate per node, used for the sampler end type type , extends ( net_state_base_t ) :: net_state_t type ( state_compartment_t ) :: infected ! Infected nodes, base type ! NB-OGA specific variables real ( kind = dp ) :: total_infection_attempt_rate ! Rate of infection attempts real ( kind = dp ) :: total_healing_rate ! Rate of healing class ( sampler_base_t ), allocatable :: possibly_quiescent_nodes_sampler ! Sampler for the infection attempts: susceptible nodes in active or inactive edges contains procedure :: init => net_state_init procedure :: add_infected => net_state_add_infected procedure :: remove_infected => net_state_remove_infected ! NB-OGA will be the default algorithm procedure :: dynamics_init => net_state_dynamics_init procedure :: dynamics_update_dt => net_state_dynamics_update_dt procedure :: dynamics_step => net_state_dynamics_step procedure :: calculate_rates => net_state_calculate_rates procedure :: print_debug_quantities => net_state_print_debug_quantities procedure :: activate_edge => net_state_activate_edge procedure :: export_edges_states => net_state_export_edges_states procedure :: get_num_infected => net_state_get_num_infected end type public :: net_state_t contains function net_state_get_num_infected ( this ) result ( n ) ! Get the number of infected nodes class ( net_state_t ), intent ( in ) :: this integer ( kind = i4 ) :: n n = this % infected % num_nodes end function net_state_get_num_infected subroutine net_state_export_edges_states ( this , net , filename ) ! Export the edges states to a file class ( net_state_t ) :: this type ( network_t ), intent ( in ) :: net character ( len =* ), intent ( in ) :: filename integer ( kind = i4 ) :: funit , i open ( newunit = funit , file = filename , status = 'unknown' , action = 'write' , position = 'append' ) write ( funit , fmt_general , advance = 'no' ) this % time do i = 1 , net % num_edges if ( this % infected % is_edge_active ( i )) write ( funit , fmt_general , advance = 'no' ) i end do write ( funit , * ) ! new line close ( funit ) end subroutine subroutine net_state_init ( this , net , params , sampler_choice ) ! It will initialize the net_state with all nodes in empty state class ( net_state_t ) :: this type ( network_t ), intent ( in ) :: net class ( dyn_parameters_t ), intent ( in ) :: params integer ( kind = i4 ) :: node_id , edge_id , edge_pos , edge_order character ( len =* ), intent ( in ) :: sampler_choice call log_write ( LOG_INFO , 'Dynamics: ' // trim ( adjustl ( ALGORITHM_NAME )), . false .) call log_write ( LOG_INFO , 'Sampler: ' // trim ( adjustl ( sampler_choice ))) ! allocate sampler call choose_sampler ( this % possibly_quiescent_nodes_sampler , sampler_choice ) this % params = params this % infected % num_nodes = 0 allocate ( this % node_state ( net % num_nodes )) allocate ( this % infected % num_infected_nodes_per_edge ( net % num_edges )) allocate ( this % infected % is_edge_active ( net % num_edges )) allocate ( this % infected % max_rate_per_node ( net % num_nodes )) this % infected % max_rate_per_node = 0.0_dp do node_id = 1 , net % num_nodes do edge_pos = 1 , net % nodes ( node_id )% degree edge_id = net % nodes ( node_id )% edges ( edge_pos ) edge_order = net % edges ( edge_id )% order this % infected % max_rate_per_node ( node_id ) = this % infected % max_rate_per_node ( node_id ) + this % params % beta ( edge_order ) end do end do this % node_state = 0 this % infected % num_infected_nodes_per_edge = 0 this % infected % is_edge_active = . false . ! initialize dynamical lists call this % infected % nodes % init ( net % num_nodes ) ! initialize the infection attempts sampler select case ( trim ( adjustl ( sampler_choice ))) case ( 'rejection_maxheap_composition' ) block real ( kind = dp ) :: min_weight , max_weight , weight integer ( kind = i4 ) :: node_id min_weight = huge ( min_weight ) max_weight = 0.0_dp do node_id = 1 , net % num_nodes weight = this % infected % max_rate_per_node ( node_id ) if ( weight < min_weight ) min_weight = weight if ( weight > max_weight ) max_weight = weight end do call this % possibly_quiescent_nodes_sampler % init ( net % num_nodes , min_weight , max_weight ) end block case ( 'rejection_two_classes' , 'rejection_maxheap_two_classes' ) block real ( kind = dp ) :: threshold , threshold_sum , threshold_std , weight integer ( kind = i4 ) :: node_id threshold_sum = 0.0_dp threshold_std = 0.0_dp do node_id = 1 , net % num_nodes weight = this % infected % max_rate_per_node ( node_id ) threshold_sum = threshold_sum + weight threshold_std = threshold_std + weight ** 2 end do threshold_std = sqrt ( threshold_std / net % num_nodes - ( threshold_sum / net % num_nodes ) ** 2 ) threshold = threshold_sum / net % num_nodes + threshold_std write ( * , fmt_general ) 'Initializing with threshold: ' , threshold call this % possibly_quiescent_nodes_sampler % init ( net % num_nodes , threshold ) end block case default call this % possibly_quiescent_nodes_sampler % init ( net % num_nodes ) end select end subroutine subroutine net_state_dynamics_init ( this , net ) ! Initialize the NB-OGA dynamics class ( net_state_t ) :: this class ( network_t ), intent ( in ) :: net ! compatibility with the other algorithms ! Set the time to zero this % time = 0.0_dp call this % calculate_rates ( net ) end subroutine subroutine net_state_calculate_rates ( this , net ) ! Calculate the rates of infection and healing class ( net_state_t ) :: this class ( network_t ), intent ( in ) :: net ! Initial healing rate is the number of infected nodes times the healing rate this % total_healing_rate = this % infected % nodes % n_used * this % params % alpha ! Loop over the active edges and calculate the total infection attempt rate this % total_infection_attempt_rate = this % params % beta_scale * this % possibly_quiescent_nodes_sampler % sum () end subroutine net_state_calculate_rates function net_state_dynamics_update_dt ( this , net , gen ) result ( res ) use rndgen_mod class ( net_state_t ) :: this class ( network_t ), intent ( in ) :: net type ( rndgen ) :: gen logical :: res res = . true . if ( this % infected % num_nodes == 0 ) then ! no infected nodes, nothing to do print * , 'No infected nodes, nothing to do.' res = . false . return end if call this % calculate_rates ( net ) this % total_rate = this % total_infection_attempt_rate + this % total_healing_rate ! Calculate the time step this % dt = - log ( 1.0_dp - gen % rnd ()) / this % total_rate ! Update the time this % time = this % time + this % dt end function subroutine net_state_dynamics_step ( this , net , gen ) use rndgen_mod ! Perform a step of the NB-OGA dynamics class ( net_state_t ) :: this class ( network_t ), intent ( in ) :: net type ( rndgen ) :: gen integer ( kind = i4 ) :: node_pos , node_id integer ( kind = i4 ) :: edge_pos , edge_id , edge_order real ( kind = dp ) :: evaluated_rate logical :: is_node_quiescent if ( gen % rnd () < this % total_healing_rate / this % total_rate ) then ! healing will happen ! we select a random infected node node_pos = gen % int ( 1 , this % infected % nodes % n_used ) node_id = this % infected % nodes % list ( node_pos ) ! remove it from the infected state and move to susceptible state call this % remove_infected ( net , node_id , node_pos , 0_i2 ) else ! infection will happen ! for that, we select a random quiescent node node_id = this % possibly_quiescent_nodes_sampler % sample ( gen ) ! now we need to check if the node is indeed in a state that can be infected evaluated_rate = 0.0_dp is_node_quiescent = . false . do edge_pos = 1 , net % nodes ( node_id )% degree edge_id = net % nodes ( node_id )% edges ( edge_pos ) edge_order = net % edges ( edge_id )% order if ( this % infected % is_edge_active ( edge_id )) then ! the edge is active, so the node is quiescent is_node_quiescent = . true . evaluated_rate = evaluated_rate + this % params % beta ( edge_order ) end if end do ! first phantom process: if the node is not quiescent, we remove it from the sampler if (. not . is_node_quiescent ) then call this % possibly_quiescent_nodes_sampler % remove ( node_id ) return end if ! now we know the quiescent node, we try to infect it if ( gen % rnd () < 1.0_dp * ( evaluated_rate ) / this % possibly_quiescent_nodes_sampler % weights ( node_id ) ) then ! we will infect that node call this % add_infected ( net , node_id ) else ! otherwise, we do nothing! Phantom process :) end if end if end subroutine ! @@@@@@@@@@@@@@@@ NB_OGA - auxiliary functions @@@@@@@@@@@@@@@@@@ subroutine check_infected_edge_condition ( this , net , edge_id , edge_order ) ! Subroutine to check if the edge is active in the infected compartment class ( net_state_t ) :: this type ( network_t ), intent ( in ) :: net integer ( kind = i4 ), intent ( in ) :: edge_id , edge_order if ( & ( this % infected % num_infected_nodes_per_edge ( edge_id ) >= this % params % theta ( edge_order )) & ! it has to have at least theta nodes in that state . and . ( this % infected % num_infected_nodes_per_edge ( edge_id ) /= net % edges ( edge_id )% order + 1 ) & ! it has to have at least one node in another state ) then ! it will be active if (. not . this % infected % is_edge_active ( edge_id )) then !print(fmt_general), 'Activating edge', edge_id, 'of order', edge_order, 'with', this%infected%num_infected_nodes_per_edge(edge_id), 'nodes in that state' call this % activate_edge ( net , edge_id , edge_order ) endif ! otherwise, it is already active else ! only change the edge status, do nothing in the list this % infected % is_edge_active ( edge_id ) = . false . end if end subroutine subroutine net_state_add_infected ( this , net , node_id ) ! Subroutine to add infected node in the list ! We assume that it was not infected before, be careful! class ( net_state_t ) :: this type ( network_t ), intent ( in ) :: net integer ( kind = i4 ), intent ( in ) :: node_id integer ( kind = i4 ) :: edge_pos , edge_id , edge_order ! DEBUG !if (this%node_state(node_id) == 1_i2) stop 'Node already infected!' this % node_state ( node_id ) = 1_i2 ! add to that state ! add node to the list this % infected % num_nodes = this % infected % num_nodes + 1 call this % infected % nodes % add ( node_id ) ! remove it from sampler, since it is now infected call this % possibly_quiescent_nodes_sampler % remove ( node_id ) ! fill the edges list ! if the edge is not active, add it. Otherwise, keep as is do edge_pos = 1 , net % nodes ( node_id )% degree edge_id = net % nodes ( node_id )% edges ( edge_pos ) edge_order = net % edges ( edge_id )% order ! add one node to that state in that edge this % infected % num_infected_nodes_per_edge ( edge_id ) = this % infected % num_infected_nodes_per_edge ( edge_id ) + 1 ! if the edge is not active, it can become active ! else, if the edge is active, it can become inactive call check_infected_edge_condition ( this , net , edge_id , edge_order ) end do end subroutine subroutine net_state_remove_infected ( this , net , node_id , node_pos , new_state ) ! Subroutine to remove infected node in the list class ( net_state_t ) :: this type ( network_t ), intent ( in ) :: net integer ( kind = i4 ), intent ( in ) :: node_id , node_pos integer ( kind = i4 ) :: edge_pos , edge_id , edge_order integer ( kind = i2 ), intent ( in ) :: new_state ! DEBUG !if (this%node_state(node_id) /= 1_i2) stop 'Node was not infected!' !if (this%infected%nodes%list(node_pos) /= node_id) stop 'Node is not the correct one!' this % node_state ( node_id ) = new_state ! add to that state ! remove node from the list of infected this % infected % num_nodes = this % infected % num_nodes - 1 call this % infected % nodes % remove ( node_pos ) ! update the status of the edges do edge_pos = 1 , net % nodes ( node_id )% degree edge_id = net % nodes ( node_id )% edges ( edge_pos ) edge_order = net % edges ( edge_id )% order this % infected % num_infected_nodes_per_edge ( edge_id ) = this % infected % num_infected_nodes_per_edge ( edge_id ) - 1 ! the number of active edges can be reduced or increased ! we check the condition call check_infected_edge_condition ( this , net , edge_id , edge_order ) end do end subroutine subroutine net_state_print_debug_quantities ( this ) ! Print debug quantities of the network state class ( net_state_t ) :: this print ( fmt_general ), 'Number of infected nodes:' , this % infected % num_nodes print ( fmt_general ), 'Number of active edges:' , count ( this % infected % is_edge_active ) !print(fmt_general), 'Number of active edges in the list:', this%infected%possibly_active_edges%n_used !print(fmt_general), 'Maximum order of possibly active edges:', this%infected%possibly_active_max_order print ( fmt_general ), 'Total infection attempt rate:' , this % total_infection_attempt_rate print ( fmt_general ), 'Total healing rate:' , this % total_healing_rate print ( fmt_general ), 'Infection attempt probability:' , & this % total_infection_attempt_rate / ( this % total_infection_attempt_rate + this % total_healing_rate ) print ( fmt_general ), '' end subroutine subroutine net_state_activate_edge ( this , net , edge_id , edge_order ) ! Subroutine to activate the edge in the compartment class ( net_state_t ) :: this class ( network_t ), intent ( in ) :: net integer ( kind = i4 ), intent ( in ) :: edge_id , edge_order integer ( kind = i4 ) :: node_id , node_pos ! DEBUG !if (this%infected%is_edge_active(edge_id)) stop 'Edge is already active!' this % infected % is_edge_active ( edge_id ) = . true . ! update the possibily quiescent nodes sampler do node_pos = 1 , net % edges ( edge_id )% order + 1 node_id = net % edges ( edge_id )% nodes ( node_pos ) ! since we are already here, we can check if the node is quiescent or not if ( this % node_state ( node_id ) == 0_i2 ) then ! the node is susceptible, so we add it to the possibly quiescent nodes sampler call this % possibly_quiescent_nodes_sampler % set_weight ( node_id , this % infected % max_rate_per_node ( node_id )) ! safe, since it will only change the weight ! code below is not necessary, since I already remove it when it is infected (add_infected) !else if (this%node_state(node_id) == 1_i2) then !    ! the node is infected, so we remove it from the possibly quiescent nodes sampler !    call this%possibly_quiescent_nodes_sampler%remove(node_id) end if end do end subroutine !/@@@@@@@@@@@@@@@@ NB_OGA @@@@@@@@@@@@@@@@@@ end module","tags":"","url":"sourcefile/dynamics_nb_oga.f90.html"},{"title":"dynamics_base.f90 – HyperSIS","text":"This file depends on sourcefile~~dynamics_base.f90~~EfferentGraph sourcefile~dynamics_base.f90 dynamics_base.f90 sourcefile~kinds.f90 kinds.f90 sourcefile~dynamics_base.f90->sourcefile~kinds.f90 sourcefile~network.f90 network.f90 sourcefile~dynamics_base.f90->sourcefile~network.f90 sourcefile~network.f90->sourcefile~kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~dynamics_base.f90~~AfferentGraph sourcefile~dynamics_base.f90 dynamics_base.f90 sourcefile~dynamics.f90 dynamics.f90 sourcefile~dynamics.f90->sourcefile~dynamics_base.f90 sourcefile~dynamics_chooser.f90 dynamics_chooser.f90 sourcefile~dynamics.f90->sourcefile~dynamics_chooser.f90 sourcefile~dynamics_chooser.f90->sourcefile~dynamics_base.f90 sourcefile~dynamics_hb_oga.f90 dynamics_HB_OGA.f90 sourcefile~dynamics_chooser.f90->sourcefile~dynamics_hb_oga.f90 sourcefile~dynamics_nb_oga.f90 dynamics_NB_OGA.f90 sourcefile~dynamics_chooser.f90->sourcefile~dynamics_nb_oga.f90 sourcefile~dynamics_hb_oga.f90->sourcefile~dynamics_base.f90 sourcefile~dynamics_nb_oga.f90->sourcefile~dynamics_base.f90 sourcefile~common.f90 common.f90 sourcefile~common.f90->sourcefile~dynamics.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module hyperSIS_dynamics_base_mod use hyperSIS_kinds_mod use hyperSIS_network_mod use datastructs_mod , only : dynamical_list_t implicit none private type , abstract :: state_compartment_base_t integer ( kind = i4 ) :: num_nodes type ( dynamical_list_t ) :: nodes ! nodes in that state logical , allocatable :: is_edge_active (:) ! if the edge contains nodes in that state and is active end type type :: dyn_parameters_t real ( kind = dp ) :: alpha ! Infection rate for each node real ( kind = dp ), allocatable , dimension (:) :: beta ! Infection rate for each edge of order m integer ( kind = i4 ), allocatable , dimension (:) :: theta ! Threshold for active edges of order m real ( kind = dp ) :: beta_scale contains procedure :: init => dyn_parameters_init procedure :: max_num_susceptible => dyn_parameters_max_num_susceptible end type type , abstract :: net_state_base_t integer ( kind = i2 ), allocatable , dimension (:) :: node_state ! State of each node type ( dyn_parameters_t ) :: params real ( kind = dp ) :: time ! Time of the state real ( kind = dp ) :: total_rate , dt contains ! base procedures (to be overridden by extended types) procedure ( net_state_base_init ), deferred :: init procedure ( net_state_base_add_infected ), deferred :: add_infected procedure ( net_state_base_remove_infected ), deferred :: remove_infected procedure ( net_state_base_dynamics_init ), deferred :: dynamics_init procedure ( net_state_base_dynamics_update_dt ), deferred :: dynamics_update_dt procedure :: just_update_dt => dynamics_just_update_dt procedure ( net_state_base_dynamics_step ), deferred :: dynamics_step ! procedure to initialize the infected nodes (no need to override) procedure , private , non_overridable :: net_state_init_config_node procedure , private , non_overridable :: net_state_init_config_list_of_nodes procedure , private , non_overridable :: net_state_init_random_fraction_of_nodes generic :: init_config => net_state_init_config_node , net_state_init_config_list_of_nodes , net_state_init_random_fraction_of_nodes ! procedure to export the nodes states procedure :: export_nodes_states => net_state_export_nodes_states ! procedure to export the nodes states (need to override) procedure ( net_state_base_export_edges_states ), deferred :: export_edges_states procedure ( get_num_infected_interface ), deferred :: get_num_infected end type abstract interface function get_num_infected_interface ( this ) result ( n ) import :: net_state_base_t , i4 class ( net_state_base_t ), intent ( in ) :: this integer ( i4 ) :: n end function ! base procedures subroutine net_state_base_init ( this , net , params , sampler_choice ) import :: net_state_base_t , network_t , dyn_parameters_t ! It will initialize the net_state with all nodes in empty state class ( net_state_base_t ) :: this type ( network_t ), intent ( in ) :: net class ( dyn_parameters_t ), intent ( in ) :: params character ( len =* ), intent ( in ) :: sampler_choice end subroutine subroutine net_state_base_dynamics_init ( this , net ) import :: net_state_base_t , network_t class ( net_state_base_t ) :: this class ( network_t ), intent ( in ) :: net end subroutine subroutine net_state_base_dynamics_step ( this , net , gen ) use rndgen_mod import :: net_state_base_t , network_t class ( net_state_base_t ) :: this class ( network_t ), intent ( in ) :: net type ( rndgen ) :: gen end subroutine function net_state_base_dynamics_update_dt ( this , net , gen ) result ( res ) ! will return .true. if the time step was updated ! will return .false. if the time step was not updated (for example, if there are no infected nodes) use rndgen_mod import :: net_state_base_t , network_t class ( net_state_base_t ) :: this class ( network_t ), intent ( in ) :: net type ( rndgen ) :: gen logical :: res end function subroutine net_state_base_add_infected ( this , net , node_id ) import :: net_state_base_t , network_t , i4 class ( net_state_base_t ) :: this type ( network_t ), intent ( in ) :: net integer ( kind = i4 ), intent ( in ) :: node_id end subroutine subroutine net_state_base_remove_infected ( this , net , node_id , node_pos , new_state ) import :: net_state_base_t , network_t , i4 , i2 class ( net_state_base_t ) :: this type ( network_t ), intent ( in ) :: net integer ( kind = i4 ), intent ( in ) :: node_id , node_pos integer ( kind = i2 ), intent ( in ) :: new_state end subroutine subroutine net_state_base_export_edges_states ( this , net , filename ) import :: net_state_base_t , network_t class ( net_state_base_t ) :: this type ( network_t ), intent ( in ) :: net character ( len =* ), intent ( in ) :: filename end subroutine !/ base procedures end interface public :: net_state_base_t , dyn_parameters_t , state_compartment_base_t contains ! just update dt (without returning a logical) subroutine dynamics_just_update_dt ( this , net , gen ) use rndgen_mod class ( net_state_base_t ) :: this class ( network_t ), intent ( in ) :: net type ( rndgen ) :: gen logical :: res res = this % dynamics_update_dt ( net , gen ) end subroutine ! subroutines to initialize the infected nodes subroutine net_state_init_config_node ( this , net , params , sampler_choice , node_id ) ! Initialize the state with a random node class ( net_state_base_t ) :: this type ( network_t ), intent ( in ) :: net integer ( kind = i4 ), intent ( in ) :: node_id class ( dyn_parameters_t ), intent ( in ) :: params character ( len =* ), intent ( in ) :: sampler_choice call net_state_init_config_list_of_nodes ( this , net , params , sampler_choice , [ node_id ]) end subroutine subroutine net_state_init_config_list_of_nodes ( this , net , params , sampler_choice , nodes ) ! Initialize the state with a random node class ( net_state_base_t ) :: this type ( network_t ), intent ( in ) :: net integer ( kind = i4 ), intent ( in ) :: nodes (:) class ( dyn_parameters_t ), intent ( in ) :: params integer ( kind = i4 ) :: node_pos character ( len =* ), intent ( in ) :: sampler_choice call this % init ( net , params , sampler_choice ) do node_pos = 1 , size ( nodes ) call this % add_infected ( net , nodes ( node_pos )) end do end subroutine subroutine net_state_init_random_fraction_of_nodes ( this , net , gen , params , sampler_choice , fraction ) use rndgen_mod ! Initialize the state with a random fraction of nodes class ( net_state_base_t ) :: this type ( network_t ), intent ( in ) :: net type ( rndgen ), intent ( in ) :: gen class ( dyn_parameters_t ), intent ( in ) :: params real ( kind = dp ), intent ( in ) :: fraction integer ( kind = i4 ) :: max_num_nodes , node_id , cnt_num_nodes character ( len =* ), intent ( in ) :: sampler_choice call this % init ( net , params , sampler_choice ) max_num_nodes = int ( fraction * net % num_nodes ) cnt_num_nodes = 0 if ( max_num_nodes == net % num_nodes ) then do node_id = 1 , net % num_nodes call add_infected ( node_id ) end do end if do while ( cnt_num_nodes < max_num_nodes ) ! Select a random node call add_infected ( gen % int ( 1 , net % num_nodes )) end do if ( this % get_num_infected () == 0 ) error stop 'No infected nodes found' contains subroutine add_infected ( node_id ) integer ( kind = i4 ), intent ( in ) :: node_id if ( this % node_state ( node_id ) == 0_i2 ) then ! If the node is not infected, infect it call this % add_infected ( net , node_id ) cnt_num_nodes = cnt_num_nodes + 1 end if end subroutine end subroutine !/ subroutines to initialize the infected nodes ! subroutines to export the states subroutine net_state_export_nodes_states ( this , net , filename ) ! Export the nodes states to a file class ( net_state_base_t ) :: this type ( network_t ), intent ( in ) :: net character ( len =* ), intent ( in ) :: filename integer ( kind = i4 ) :: funit , i open ( newunit = funit , file = filename , status = 'unknown' , action = 'write' , position = 'append' ) write ( funit , fmt_general , advance = 'no' ) this % time do i = 1 , net % num_nodes if ( this % node_state ( i ) /= 0 ) write ( funit , fmt_general , advance = 'no' ) i end do write ( funit , * ) ! new line close ( funit ) end subroutine ! subroutines for the dynamical parameters subroutine dyn_parameters_init ( this , net ) class ( dyn_parameters_t ) :: this type ( network_t ) :: net allocate ( this % beta ( net % max_order )) allocate ( this % theta ( net % max_order )) ! Set default scale this % beta_scale = 1.0_dp ! Set default values this % alpha = 1.0_dp this % beta = 1.0_dp this % theta = 1 end subroutine function dyn_parameters_max_num_susceptible ( this , edge_order ) result ( res ) ! Function to return the maximum number of susceptible nodes in an edge of order m class ( dyn_parameters_t ) :: this integer ( kind = i4 ), intent ( in ) :: edge_order integer ( kind = i4 ) :: res res = ( edge_order + 1 - this % theta ( edge_order )) end function !/ subroutines for the dynamical parameters end module","tags":"","url":"sourcefile/dynamics_base.f90.html"},{"title":"dynamics.f90 – HyperSIS","text":"This file depends on sourcefile~~dynamics.f90~~EfferentGraph sourcefile~dynamics.f90 dynamics.f90 sourcefile~dynamics_base.f90 dynamics_base.f90 sourcefile~dynamics.f90->sourcefile~dynamics_base.f90 sourcefile~dynamics_chooser.f90 dynamics_chooser.f90 sourcefile~dynamics.f90->sourcefile~dynamics_chooser.f90 sourcefile~kinds.f90 kinds.f90 sourcefile~dynamics_base.f90->sourcefile~kinds.f90 sourcefile~network.f90 network.f90 sourcefile~dynamics_base.f90->sourcefile~network.f90 sourcefile~dynamics_chooser.f90->sourcefile~dynamics_base.f90 sourcefile~dynamics_hb_oga.f90 dynamics_HB_OGA.f90 sourcefile~dynamics_chooser.f90->sourcefile~dynamics_hb_oga.f90 sourcefile~dynamics_nb_oga.f90 dynamics_NB_OGA.f90 sourcefile~dynamics_chooser.f90->sourcefile~dynamics_nb_oga.f90 sourcefile~dynamics_chooser.f90->sourcefile~kinds.f90 sourcefile~dynamics_hb_oga.f90->sourcefile~dynamics_base.f90 sourcefile~dynamics_hb_oga.f90->sourcefile~kinds.f90 sourcefile~dynamics_hb_oga.f90->sourcefile~network.f90 sourcefile~dynamics_nb_oga.f90->sourcefile~dynamics_base.f90 sourcefile~dynamics_nb_oga.f90->sourcefile~kinds.f90 sourcefile~dynamics_nb_oga.f90->sourcefile~network.f90 sourcefile~network.f90->sourcefile~kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~dynamics.f90~~AfferentGraph sourcefile~dynamics.f90 dynamics.f90 sourcefile~common.f90 common.f90 sourcefile~common.f90->sourcefile~dynamics.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module hyperSIS_dynamics_mod use hyperSIS_dynamics_chooser_mod , only : net_state_choose , dynamics_choices => alg_choices use hyperSIS_dynamics_base_mod , only : dyn_parameters_t , net_state_base_t implicit none private public :: net_state_base_t , dyn_parameters_t , net_state_choose , dynamics_choices end module","tags":"","url":"sourcefile/dynamics.f90.html"},{"title":"dynamics_HB_OGA.f90 – HyperSIS","text":"This file depends on sourcefile~~dynamics_hb_oga.f90~~EfferentGraph sourcefile~dynamics_hb_oga.f90 dynamics_HB_OGA.f90 sourcefile~dynamics_base.f90 dynamics_base.f90 sourcefile~dynamics_hb_oga.f90->sourcefile~dynamics_base.f90 sourcefile~kinds.f90 kinds.f90 sourcefile~dynamics_hb_oga.f90->sourcefile~kinds.f90 sourcefile~network.f90 network.f90 sourcefile~dynamics_hb_oga.f90->sourcefile~network.f90 sourcefile~dynamics_base.f90->sourcefile~kinds.f90 sourcefile~dynamics_base.f90->sourcefile~network.f90 sourcefile~network.f90->sourcefile~kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~dynamics_hb_oga.f90~~AfferentGraph sourcefile~dynamics_hb_oga.f90 dynamics_HB_OGA.f90 sourcefile~dynamics_chooser.f90 dynamics_chooser.f90 sourcefile~dynamics_chooser.f90->sourcefile~dynamics_hb_oga.f90 sourcefile~dynamics.f90 dynamics.f90 sourcefile~dynamics.f90->sourcefile~dynamics_chooser.f90 sourcefile~common.f90 common.f90 sourcefile~common.f90->sourcefile~dynamics.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module hyperSIS_dynamics_HB_OGA_mod use hyperSIS_kinds_mod use hyperSIS_network_mod use hyperSIS_dynamics_base_mod use datastructs_mod , only : dynamical_list_t use datastructs_mod , only : sampler_base_t use datastructs_mod , only : choose_sampler use datastructs_mod , only : log_unit , log_write , LOGGER_OK , LOG_ERROR , LOG_WARNING , LOG_INFO , LOG_DEBUG implicit none private character ( len =* ), parameter :: ALGORITHM_NAME = 'HB_OGA' type , extends ( state_compartment_base_t ) :: state_compartment_t integer ( kind = i4 ), allocatable :: num_infected_nodes_per_edge (:) ! number of nodes in that state in that edge end type type , extends ( net_state_base_t ) :: net_state_t type ( state_compartment_t ) :: infected ! Infected nodes, base type ! HB-OGA specific variables real ( kind = dp ) :: total_infection_attempt_rate ! Rate of infection attempts real ( kind = dp ) :: total_healing_rate ! Rate of healing class ( sampler_base_t ), allocatable :: infection_attempts_sampler ! Sampler for the infection attempts contains procedure :: init => net_state_init procedure :: add_infected => net_state_add_infected procedure :: remove_infected => net_state_remove_infected ! HB-OGA will be the default algorithm procedure :: dynamics_init => net_state_dynamics_init procedure :: dynamics_update_dt => net_state_dynamics_update_dt procedure :: dynamics_step => net_state_dynamics_step procedure :: calculate_rates => net_state_calculate_rates procedure :: print_debug_quantities => net_state_print_debug_quantities procedure :: remove_possibly_active_edge => net_state_remove_possibly_active_edge_from_list procedure :: activate_edge => net_state_activate_edge procedure :: export_edges_states => net_state_export_edges_states procedure :: get_num_infected => net_state_get_num_infected end type public :: net_state_t contains function net_state_get_num_infected ( this ) result ( n ) ! Get the number of infected nodes class ( net_state_t ), intent ( in ) :: this integer ( kind = i4 ) :: n n = this % infected % num_nodes end function net_state_get_num_infected subroutine net_state_export_edges_states ( this , net , filename ) ! Export the edges states to a file class ( net_state_t ) :: this type ( network_t ), intent ( in ) :: net character ( len =* ), intent ( in ) :: filename integer ( kind = i4 ) :: funit , i open ( newunit = funit , file = filename , status = 'unknown' , action = 'write' , position = 'append' ) write ( funit , fmt_general , advance = 'no' ) this % time do i = 1 , net % num_edges if ( this % infected % is_edge_active ( i )) write ( funit , fmt_general , advance = 'no' ) i end do write ( funit , * ) ! new line close ( funit ) end subroutine subroutine net_state_init ( this , net , params , sampler_choice ) ! It will initialize the net_state with all nodes in empty state class ( net_state_t ) :: this type ( network_t ), intent ( in ) :: net class ( dyn_parameters_t ), intent ( in ) :: params character ( len =* ), intent ( in ) :: sampler_choice call log_write ( LOG_INFO , 'Dynamics: ' // trim ( adjustl ( ALGORITHM_NAME )), . false .) call log_write ( LOG_INFO , 'Sampler: ' // trim ( adjustl ( sampler_choice ))) ! allocate sampler call choose_sampler ( this % infection_attempts_sampler , sampler_choice ) this % params = params this % infected % num_nodes = 0 allocate ( this % node_state ( net % num_nodes )) allocate ( this % infected % num_infected_nodes_per_edge ( net % num_edges )) allocate ( this % infected % is_edge_active ( net % num_edges )) this % node_state = 0 this % infected % num_infected_nodes_per_edge = 0 this % infected % is_edge_active = . false . ! initialize dynamical lists call this % infected % nodes % init ( net % num_nodes ) ! initialize the infection attempts sampler select case ( trim ( adjustl ( sampler_choice ))) case ( 'rejection_maxheap_composition' ) block real ( kind = dp ) :: min_weight , max_weight , weight integer ( kind = i4 ) :: edge_order min_weight = huge ( min_weight ) max_weight = 0.0_dp do edge_order = 1 , net % max_order weight = this % params % beta ( edge_order ) * this % params % max_num_susceptible ( edge_order ) if ( weight < min_weight ) min_weight = weight if ( weight > max_weight ) max_weight = weight end do call this % infection_attempts_sampler % init ( net % num_edges , min_weight , max_weight ) end block case ( 'rejection_two_classes' , 'rejection_maxheap_two_classes' ) block real ( kind = dp ) :: threshold , threshold_sum , threshold_std , weight integer ( kind = i4 ) :: edge_order threshold_sum = 0.0_dp threshold_std = 0.0_dp do edge_order = 1 , net % max_order weight = this % params % beta ( edge_order ) * this % params % max_num_susceptible ( edge_order ) threshold_sum = threshold_sum + weight threshold_std = threshold_std + weight ** 2 end do threshold_std = sqrt ( threshold_std / net % max_order - ( threshold_sum / net % max_order ) ** 2 ) threshold = threshold_sum / net % max_order + threshold_std write ( * , fmt_general ) 'Initializing with threshold: ' , threshold call this % infection_attempts_sampler % init ( net % num_edges , threshold ) end block case default call this % infection_attempts_sampler % init ( net % num_edges ) end select end subroutine subroutine net_state_dynamics_init ( this , net ) ! Initialize the HB-OGA dynamics class ( net_state_t ) :: this class ( network_t ), intent ( in ) :: net ! compatibility with the other algorithms ! Set the time to zero this % time = 0.0_dp call this % calculate_rates ( net ) end subroutine subroutine net_state_calculate_rates ( this , net ) ! Calculate the rates of infection and healing class ( net_state_t ) :: this class ( network_t ), intent ( in ) :: net ! Initial healing rate is the number of infected nodes times the healing rate this % total_healing_rate = this % infected % nodes % n_used * this % params % alpha ! Loop over the active edges and calculate the total infection attempt rate this % total_infection_attempt_rate = this % params % beta_scale * this % infection_attempts_sampler % sum () end subroutine net_state_calculate_rates function net_state_dynamics_update_dt ( this , net , gen ) result ( res ) use rndgen_mod class ( net_state_t ) :: this class ( network_t ), intent ( in ) :: net type ( rndgen ) :: gen logical :: res res = . true . if ( this % infected % num_nodes == 0 ) then ! no infected nodes, nothing to do print * , 'No infected nodes, nothing to do.' res = . false . return end if call this % calculate_rates ( net ) this % total_rate = this % total_infection_attempt_rate + this % total_healing_rate ! Calculate the time step this % dt = - log ( 1.0_dp - gen % rnd ()) / this % total_rate ! Update the time this % time = this % time + this % dt end function subroutine net_state_dynamics_step ( this , net , gen ) use rndgen_mod ! Perform a step of the HB-OGA dynamics class ( net_state_t ) :: this class ( network_t ), intent ( in ) :: net type ( rndgen ) :: gen integer ( kind = i4 ) :: node_pos , node_id integer ( kind = i4 ) :: edge_id , edge_order , edge_num_susceptible if ( gen % rnd () < this % total_healing_rate / this % total_rate ) then ! healing will happen ! we select a random infected node node_pos = gen % int ( 1 , this % infected % nodes % n_used ) node_id = this % infected % nodes % list ( node_pos ) ! remove it from the infected state and move to susceptible state call this % remove_infected ( net , node_id , node_pos , 0_i2 ) else ! infection will happen ! for that, we select a random active edge using rejection sampling edge_id = this % infection_attempts_sampler % sample ( gen ) edge_order = net % edges ( edge_id )% order ! if not active, we only remove it from the list if (. not . this % infected % is_edge_active ( edge_id )) then ! we only remove that edge from the list (phantom process) call this % remove_possibly_active_edge ( edge_id , edge_order ) return ! nothing to do, we just remove the edge from the list end if ! here, the edge is indeed active, so we will try to infect a node in that edge !print*, 'accepted edge', edge_id, 'of order', edge_order, 'with', this%infected%num_infected_nodes_per_edge(edge_id), 'nodes in that state' edge_num_susceptible = edge_order + 1 - this % infected % num_infected_nodes_per_edge ( edge_id ) !print*, edge_num_susceptible, this%params%max_num_susceptible(edge_order) ! now we know the active edge, and see if we will indeed infect a node if ( gen % rnd () < 1.0_dp * ( edge_num_susceptible ) / this % params % max_num_susceptible ( edge_order ) ) then ! we will infect a node in that edge, using a list of susceptible individuals block integer ( kind = i4 ) :: list_of_sus ( edge_num_susceptible ) integer ( kind = i4 ) :: sus_pos sus_pos = 0 do node_pos = 1 , net % edges ( edge_id )% order + 1 node_id = net % edges ( edge_id )% nodes ( node_pos ) if ( this % node_state ( node_id ) == 0_i2 ) then sus_pos = sus_pos + 1 list_of_sus ( sus_pos ) = node_id end if end do ! DEBUG !if (list_of_sus%n_used /= edge_num_susceptible) stop 'eita' node_pos = gen % int ( 1 , edge_num_susceptible ) node_id = list_of_sus ( node_pos ) call this % add_infected ( net , node_id ) end block else ! otherwise, we do nothing! Phantom process :) end if end if end subroutine ! @@@@@@@@@@@@@@@@ HB_OGA - auxiliary functions @@@@@@@@@@@@@@@@@@ subroutine check_infected_edge_condition ( this , net , edge_id , edge_order ) ! Subroutine to check if the edge is active in the infected compartment class ( net_state_t ) :: this type ( network_t ), intent ( in ) :: net integer ( kind = i4 ), intent ( in ) :: edge_id , edge_order if ( & ( this % infected % num_infected_nodes_per_edge ( edge_id ) >= this % params % theta ( edge_order )) & ! it has to have at least theta nodes in that state . and . ( this % infected % num_infected_nodes_per_edge ( edge_id ) /= net % edges ( edge_id )% order + 1 ) & ! it has to have at least one node in another state ) then ! it will be active if (. not . this % infected % is_edge_active ( edge_id )) then !print(fmt_general), 'Activating edge', edge_id, 'of order', edge_order, 'with', this%infected%num_infected_nodes_per_edge(edge_id), 'nodes in that state' call this % activate_edge ( edge_id , edge_order ) endif ! otherwise, it is already active else ! only change the edge status, do nothing in the list this % infected % is_edge_active ( edge_id ) = . false . end if end subroutine subroutine net_state_add_infected ( this , net , node_id ) ! Subroutine to add infected node in the list ! We assume that it was not infected before, be careful! class ( net_state_t ) :: this type ( network_t ), intent ( in ) :: net integer ( kind = i4 ), intent ( in ) :: node_id integer ( kind = i4 ) :: edge_pos , edge_id , edge_order ! DEBUG !if (this%node_state(node_id) == 1_i2) stop 'Node already infected!' this % node_state ( node_id ) = 1_i2 ! add to that state ! add node to the list this % infected % num_nodes = this % infected % num_nodes + 1 call this % infected % nodes % add ( node_id ) ! fill the edges list ! if the edge is not active, add it. Otherwise, keep as is do edge_pos = 1 , net % nodes ( node_id )% degree edge_id = net % nodes ( node_id )% edges ( edge_pos ) edge_order = net % edges ( edge_id )% order ! add one node to that state in that edge this % infected % num_infected_nodes_per_edge ( edge_id ) = this % infected % num_infected_nodes_per_edge ( edge_id ) + 1 ! if the edge is not active, it can become active ! else, if the edge is active, it can become inactive call check_infected_edge_condition ( this , net , edge_id , edge_order ) end do end subroutine subroutine net_state_remove_infected ( this , net , node_id , node_pos , new_state ) ! Subroutine to remove infected node in the list ! CAUTION: WILL NOT UPDATE THE ACTIVE EDGES LIST class ( net_state_t ) :: this type ( network_t ), intent ( in ) :: net integer ( kind = i4 ), intent ( in ) :: node_id , node_pos integer ( kind = i4 ) :: edge_pos , edge_id , edge_order integer ( kind = i2 ), intent ( in ) :: new_state ! DEBUG !if (this%node_state(node_id) /= 1_i2) stop 'Node was not infected!' !if (this%infected%nodes%list(node_pos) /= node_id) stop 'Node is not the correct one!' this % node_state ( node_id ) = new_state ! add to that state ! remove node from the list this % infected % num_nodes = this % infected % num_nodes - 1 call this % infected % nodes % remove ( node_pos ) ! update the status of the edges do edge_pos = 1 , net % nodes ( node_id )% degree edge_id = net % nodes ( node_id )% edges ( edge_pos ) edge_order = net % edges ( edge_id )% order this % infected % num_infected_nodes_per_edge ( edge_id ) = this % infected % num_infected_nodes_per_edge ( edge_id ) - 1 ! the number of active edges can be reduced or increased ! we check the condition call check_infected_edge_condition ( this , net , edge_id , edge_order ) end do end subroutine subroutine net_state_print_debug_quantities ( this ) ! Print debug quantities of the network state class ( net_state_t ) :: this print ( fmt_general ), 'Number of infected nodes:' , this % infected % num_nodes print ( fmt_general ), 'Number of active edges:' , count ( this % infected % is_edge_active ) !print(fmt_general), 'Number of active edges in the list:', this%infected%possibly_active_edges%n_used !print(fmt_general), 'Maximum order of possibly active edges:', this%infected%possibly_active_max_order print ( fmt_general ), 'Total infection attempt rate:' , this % total_infection_attempt_rate print ( fmt_general ), 'Total healing rate:' , this % total_healing_rate print ( fmt_general ), 'Infection attempt probability:' , & this % total_infection_attempt_rate / ( this % total_infection_attempt_rate + this % total_healing_rate ) print ( fmt_general ), '' end subroutine subroutine net_state_remove_possibly_active_edge_from_list ( this , edge_id , edge_order ) class ( net_state_t ) :: this integer ( kind = i4 ), intent ( in ) :: edge_id , edge_order ! Remove the edge from the active edges list ! DEBUG !if (.not. this%infected%is_edge_in_weighted_sampler(edge_id)) stop 'Edge is not in the active edges list!' !if (this%infected%is_edge_active(edge_id)) stop 'Edge is active!' call this % infection_attempts_sampler % remove ( edge_id ) end subroutine subroutine net_state_activate_edge ( this , edge_id , edge_order ) ! Subroutine to activate the edge in the compartment class ( net_state_t ) :: this integer ( kind = i4 ), intent ( in ) :: edge_id , edge_order ! DEBUG !if (this%infected%is_edge_active(edge_id)) stop 'Edge is already active!' this % infected % is_edge_active ( edge_id ) = . true . call this % infection_attempts_sampler % set_weight ( edge_id , this % params % beta ( edge_order ) * this % params % max_num_susceptible ( edge_order )) end subroutine !/@@@@@@@@@@@@@@@@ HB_OGA @@@@@@@@@@@@@@@@@@ end module","tags":"","url":"sourcefile/dynamics_hb_oga.f90.html"},{"title":"network_io.f90 – HyperSIS","text":"This file depends on sourcefile~~network_io.f90~~EfferentGraph sourcefile~network_io.f90 network_io.f90 sourcefile~kinds.f90 kinds.f90 sourcefile~network_io.f90->sourcefile~kinds.f90 sourcefile~network.f90 network.f90 sourcefile~network_io.f90->sourcefile~network.f90 sourcefile~network.f90->sourcefile~kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~network_io.f90~~AfferentGraph sourcefile~network_io.f90 network_io.f90 sourcefile~common.f90 common.f90 sourcefile~common.f90->sourcefile~network_io.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module hyperSIS_network_io_mod use hyperSIS_kinds_mod use hyperSIS_network_mod use datastructs_mod , only : log_unit , log_write , LOGGER_OK , LOG_ERROR , LOG_WARNING , LOG_INFO , LOG_DEBUG implicit none private public :: network_export , network_import contains subroutine network_import ( net , filename , skip_check_consistency ) class ( network_t ), intent ( inout ) :: net character ( len =* ), intent ( in ) :: filename logical , optional :: skip_check_consistency logical :: skip_check_consistency_choice if ( present ( skip_check_consistency )) then skip_check_consistency_choice = skip_check_consistency else skip_check_consistency_choice = . false . end if call network_import_edgelist ( net , filename ) if (. not . skip_check_consistency_choice ) then call net % check_topology_consistency () end if end subroutine function file_exists ( filename ) result ( res ) character ( len =* ), intent ( in ) :: filename logical :: res integer ( kind = i4 ) :: ios inquire ( file = filename , exist = res , iostat = ios ) if ( ios /= 0 ) then res = . false . end if end function subroutine network_import_edgelist ( net , filename_net ) use , intrinsic :: iso_fortran_env , only : iostat_end use datastructs_mod , only : fixed_list_t , new_fixed_list_pointer class ( network_t ) :: net character ( len =* ), intent ( in ) :: filename_net integer ( kind = i4 ) :: unit_net type ( fixed_list_t ), pointer :: edge_head => null (), edge_tail => null (), edge_current => null () open ( newunit = unit_net , file = filename_net , status = 'old' , action = 'read' ) ! read the number of nodes from the net file block integer ( kind = i4 ) :: num_nodes , num_edges integer ( kind = i4 ) :: flag integer ( kind = i4 ), allocatable :: nodes (:) character ( len = :), allocatable :: str_aux allocate ( character ( len = 100000 ) :: str_aux ) num_nodes = 0 num_edges = 0 rewind ( unit_net ) do read ( unit_net , '(a)' , iostat = flag ) str_aux if ( flag == iostat_end ) exit allocate ( nodes ( count_integers_from_string ( str_aux ))) read ( str_aux , * ) nodes num_nodes = max ( num_nodes , maxval ( nodes )) num_edges = num_edges + 1 allocate ( edge_current ) call move_alloc ( nodes , edge_current % list ) edge_current % next => null () if ( num_edges == 1 ) then edge_head => edge_current edge_tail => edge_current edge_current % prev => null () else edge_tail % next => edge_current edge_current % prev => edge_tail edge_tail => edge_current end if end do close ( unit_net ) ! allocate the nodes net % num_nodes = num_nodes net % num_edges = num_edges allocate ( net % nodes ( num_nodes )) allocate ( net % edges ( num_edges )) deallocate ( str_aux ) end block ! now, calculate the degree of each node and hyperedge block ! save the file to not need to read from it again later integer ( kind = i4 ) :: node_id , edge_id , i integer ( kind = i4 ), allocatable :: nodes (:) net % nodes (:)% degree = 0 net % edges (:)% order = - 1 edge_current => edge_head edge_id = 1 do while ( associated ( edge_current )) call move_alloc ( edge_current % list , nodes ) net % edges ( edge_id )% order = size ( nodes ) - 1 do i = 1 , size ( nodes ) node_id = nodes ( i ) net % nodes ( node_id )% degree = net % nodes ( node_id )% degree + 1 end do call move_alloc ( nodes , net % edges ( edge_id )% nodes ) edge_current => edge_current % next edge_id = edge_id + 1 end do call destroy_list ( edge_head , edge_tail ) ! now, allocate the nodes arrays do node_id = 1 , net % num_nodes allocate ( net % nodes ( node_id )% edges ( net % nodes ( node_id )% degree )) end do call net % build_nodes_from_edges () end block contains subroutine destroy_list ( head , tail ) type ( fixed_list_t ), pointer :: head , tail type ( fixed_list_t ), pointer :: ptr , temp ptr => head do while ( associated ( ptr )) temp => ptr % next if ( allocated ( ptr % list )) deallocate ( ptr % list ) deallocate ( ptr ) ptr => temp end do nullify ( head ) nullify ( tail ) end subroutine end subroutine network_import_edgelist subroutine network_export ( net , filename ) class ( network_t ), intent ( in ) :: net character ( len =* ), intent ( in ) :: filename call network_export_edgelist ( net , filename ) end subroutine !> Export the network as hyperedges list (default) subroutine network_export_edgelist ( net , filename_net ) use , intrinsic :: iso_fortran_env , only : iostat_end class ( network_t ) :: net character ( len =* ), intent ( in ) :: filename_net integer ( kind = i4 ) :: unit_net integer ( kind = i4 ) :: edge_id character ( len = :), allocatable :: fmt fmt = fmt_general ! will never use CSV open ( newunit = unit_net , file = filename_net , status = 'replace' , action = 'write' ) do edge_id = 1 , net % num_edges write ( unit_net , fmt ) net % edges ( edge_id )% nodes end do close ( unit_net ) end subroutine network_export_edgelist end module","tags":"","url":"sourcefile/network_io.f90.html"},{"title":"network.f90 – HyperSIS","text":"This file depends on sourcefile~~network.f90~~EfferentGraph sourcefile~network.f90 network.f90 sourcefile~kinds.f90 kinds.f90 sourcefile~network.f90->sourcefile~kinds.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~network.f90~~AfferentGraph sourcefile~network.f90 network.f90 sourcefile~common.f90 common.f90 sourcefile~common.f90->sourcefile~network.f90 sourcefile~network_io.f90 network_io.f90 sourcefile~common.f90->sourcefile~network_io.f90 sourcefile~dynamics.f90 dynamics.f90 sourcefile~common.f90->sourcefile~dynamics.f90 sourcefile~dynamics_base.f90 dynamics_base.f90 sourcefile~dynamics_base.f90->sourcefile~network.f90 sourcefile~dynamics_hb_oga.f90 dynamics_HB_OGA.f90 sourcefile~dynamics_hb_oga.f90->sourcefile~network.f90 sourcefile~dynamics_hb_oga.f90->sourcefile~dynamics_base.f90 sourcefile~dynamics_nb_oga.f90 dynamics_NB_OGA.f90 sourcefile~dynamics_nb_oga.f90->sourcefile~network.f90 sourcefile~dynamics_nb_oga.f90->sourcefile~dynamics_base.f90 sourcefile~network_io.f90->sourcefile~network.f90 sourcefile~dynamics.f90->sourcefile~dynamics_base.f90 sourcefile~dynamics_chooser.f90 dynamics_chooser.f90 sourcefile~dynamics.f90->sourcefile~dynamics_chooser.f90 sourcefile~dynamics_chooser.f90->sourcefile~dynamics_base.f90 sourcefile~dynamics_chooser.f90->sourcefile~dynamics_hb_oga.f90 sourcefile~dynamics_chooser.f90->sourcefile~dynamics_nb_oga.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module hyperSIS_network_mod use hyperSIS_kinds_mod use datastructs_mod , only : dynamical_list_t , fixed_list_t use datastructs_mod , only : log_unit , log_write , LOGGER_OK , LOG_ERROR , LOG_WARNING , LOG_INFO , LOG_DEBUG implicit none private !> Interface for the constructor of the network type. interface network module procedure network_new end interface !> Interface for the constructor of the hyperedge type. !> It receives the order OR a list of nodes and returns a new hyperedge object. interface hyperedge module procedure hyperedge_new , hyperedge_new_from_nodes_list end interface !> Hyperedge object to represent a hyperedge in the network. !> It contains an ID, order m, and list of m + 1 nodes belonging to the hyperedge. type hyperedge_t integer ( kind = i4 ) :: order = - 1 integer ( kind = i4 ), allocatable :: nodes (:), dual_edges (:) end type !> Node object to represent a node in the network. !> It contains an ID, degree, and list of hyperedges that the node belongs to. type node_t integer ( kind = i4 ) :: degree = 0 integer ( kind = i4 ), allocatable :: edges (:), dual_nodes (:) end type type network_props_t logical :: cleaned_null_edges = . false . ! .true. if all edges have at least a min_order logical :: removed_invalid_nodes_and_edges = . false . ! .true. if all nodes and edges are valid logical :: checked_topology_consistency = . false . ! .true. if the topology is consistent (nodes are connected to edges and vice versa) integer ( kind = i4 ) :: min_order = - 1 ! minimum order of the edges end type !> Network object to represent the entire hypergraph. !> It contains the number of nodes, number of edges, and arrays of nodes and edges objects. type :: network_t integer ( kind = i4 ) :: num_nodes = 0 integer ( kind = i4 ) :: num_edges = 0 integer ( kind = i4 ) :: max_order = 0 type ( node_t ), allocatable :: nodes (:) type ( hyperedge_t ), allocatable :: edges (:) type ( network_props_t ) :: props ! extra properties type ( fixed_list_t ), allocatable :: nodes_per_degree (:), edges_per_order (:) contains procedure :: init => network_init procedure :: build_edges_from_nodes => network_build_edges_from_nodes procedure :: build_nodes_from_edges => network_build_nodes_from_edges procedure :: print_nodes_and_edges => network_print_nodes_and_edges procedure :: clear_null_edges => network_clear_null_edges ! we can only remove the null edges (order -1) procedure :: check_topology_consistency => network_check_topology_consistency ! we can only check the topology consistency procedure :: remove_invalid_nodes_and_edges => network_remove_invalid_nodes_and_edges procedure :: clear_and_check_all => network_clear_and_check_all ! we can only check the topology consistency procedure :: reset_props => network_reset_props procedure :: destroy => network_destroy final :: network_finalizer end type public :: network , hyperedge public :: network_t , hyperedge_t , node_t contains subroutine network_reset_props ( net ) class ( network_t ), intent ( inout ) :: net net % props % cleaned_null_edges = . false . net % props % removed_invalid_nodes_and_edges = . false . net % props % checked_topology_consistency = . false . net % props % min_order = - 1 end subroutine network_reset_props subroutine network_clear_and_check_all ( net , min_order ) class ( network_t ), intent ( inout ) :: net integer ( kind = i4 ), intent ( in ), optional :: min_order net % max_order = maxval ( net % edges (:)% order ) if ((. not . net % props % cleaned_null_edges ) . or . ( min_order /= net % props % min_order )) call net % clear_null_edges ( min_order ) if (. not . net % props % removed_invalid_nodes_and_edges ) call net % remove_invalid_nodes_and_edges () if (. not . net % props % checked_topology_consistency ) call net % check_topology_consistency () end subroutine network_clear_and_check_all subroutine network_remove_invalid_nodes_and_edges ( net ) class ( network_t ), intent ( inout ) :: net ! It will remove the nodes with degree 0 ! and edges with order -1 ! It will be necessary to reindex everything ! Check nodes with degree = 0 block integer ( kind = i4 ), allocatable :: new_nodes_indexes (:) integer ( kind = i4 ), allocatable :: new_edges_indexes (:) integer ( kind = i4 ) :: new_num_nodes , new_num_edges , i , j , node_id , edge_id type ( node_t ), allocatable :: new_nodes (:) type ( hyperedge_t ), allocatable :: new_edges (:) allocate ( new_nodes_indexes ( net % num_nodes )) allocate ( new_nodes ( net % num_nodes )) new_num_nodes = 0 new_nodes_indexes = - 1 do node_id = 1 , net % num_nodes if ( net % nodes ( node_id )% degree /= 0 ) then new_num_nodes = new_num_nodes + 1 new_nodes_indexes ( node_id ) = new_num_nodes block integer ( kind = i4 ), allocatable :: new_edges_list (:) integer ( kind = i4 ) :: new_degree allocate ( new_edges_list ( net % nodes ( node_id )% degree )) new_degree = 0 do j = 1 , net % nodes ( node_id )% degree edge_id = net % nodes ( node_id )% edges ( j ) if ( net % edges ( edge_id )% order /= - 1 ) then ! valid edge new_degree = new_degree + 1 new_edges_list ( new_degree ) = edge_id end if end do deallocate ( net % nodes ( node_id )% edges ) net % nodes ( node_id )% degree = new_degree net % nodes ( node_id )% edges = new_edges_list ( 1 : new_degree ) new_nodes ( new_num_nodes ) = net % nodes ( node_id ) end block end if end do deallocate ( net % nodes ) allocate ( net % nodes ( new_num_nodes )) net % num_nodes = new_num_nodes net % nodes = new_nodes ( 1 : new_num_nodes ) deallocate ( new_nodes ) call log_write ( LOG_DEBUG , 'New number of nodes:' , net % num_nodes ) ! Now, we need to reindex the nodes in each edge, and remove those with order -1 allocate ( new_edges_indexes ( net % num_edges )) allocate ( new_edges ( net % num_edges )) new_num_edges = 0 new_edges_indexes = - 1 do edge_id = 1 , net % num_edges if ( net % edges ( edge_id )% order /= - 1 ) then new_num_edges = new_num_edges + 1 new_edges_indexes ( edge_id ) = new_num_edges ! reindex the nodes in the edge do i = 1 , net % edges ( edge_id )% order + 1 node_id = net % edges ( edge_id )% nodes ( i ) if ( new_nodes_indexes ( node_id ) == - 1 ) error stop 'should not happen! [node_id]' net % edges ( edge_id )% nodes ( i ) = new_nodes_indexes ( node_id ) end do new_edges ( new_num_edges ) = net % edges ( edge_id ) end if end do deallocate ( net % edges ) allocate ( net % edges ( new_num_edges )) net % num_edges = new_num_edges net % edges = new_edges ( 1 : new_num_edges ) deallocate ( new_edges ) call log_write ( LOG_DEBUG , 'New number of edges:' , net % num_edges ) ! Finally, update the edge_ids in the nodes do node_id = 1 , net % num_nodes do i = 1 , net % nodes ( node_id )% degree edge_id = net % nodes ( node_id )% edges ( i ) if ( new_edges_indexes ( edge_id ) == - 1 ) error stop 'should not happen! [edge_id]' net % nodes ( node_id )% edges ( i ) = new_edges_indexes ( edge_id ) end do end do end block net % props % checked_topology_consistency = . false . net % props % removed_invalid_nodes_and_edges = . true . end subroutine subroutine network_clear_null_edges ( net , min_order_input ) class ( network_t ), intent ( inout ) :: net integer ( kind = i4 ), intent ( in ), optional :: min_order_input integer ( kind = i4 ) :: min_order , i , j , edge_id , node_id , count integer ( kind = i4 ), allocatable :: edges_with_smaller_order (:) if ( present ( min_order_input )) then min_order = min_order_input else min_order = 1 ! default is to have at least two nodes end if ! loop over the edges ! if the order is less than min_order, remove the edge ! and update the respective nodes count = 0 do i = 1 , net % num_edges if ( net % edges ( i )% order < min_order ) then count = count + 1 end if end do allocate ( edges_with_smaller_order ( count )) count = 0 do i = 1 , net % num_edges if ( net % edges ( i )% order < min_order ) then count = count + 1 edges_with_smaller_order ( count ) = i end if end do call log_write ( LOG_DEBUG , 'Number of edges with order smaller than' , min_order , . false .) call log_write ( LOG_DEBUG , 'is' , size ( edges_with_smaller_order )) do i = 1 , size ( edges_with_smaller_order ) edge_id = edges_with_smaller_order ( i ) ! we will loop over the nodes and delete the respective position there and shrink the list do j = 1 , net % edges ( edge_id )% order + 1 node_id = net % edges ( edge_id )% nodes ( j ) call clear_node_id_edges_list () end do ! remove edge net % edges ( edge_id )% order = - 1 deallocate ( net % edges ( edge_id )% nodes ) end do net % props % min_order = min_order net % props % cleaned_null_edges = . true . net % props % checked_topology_consistency = . false . contains subroutine clear_node_id_edges_list () integer ( kind = i4 ) :: i , j , new_degree integer ( kind = i4 ), allocatable :: new_edges (:) new_degree = net % nodes ( node_id )% degree do i = 1 , net % nodes ( node_id )% degree if ( net % nodes ( node_id )% edges ( i ) == edge_id ) then net % nodes ( node_id )% edges ( i ) = net % nodes ( node_id )% edges ( new_degree ) new_degree = new_degree - 1 end if end do net % nodes ( node_id )% degree = new_degree allocate ( new_edges ( new_degree )) new_edges ( 1 : new_degree ) = net % nodes ( node_id )% edges ( 1 : new_degree ) call move_alloc ( new_edges , net % nodes ( node_id )% edges ) end subroutine end subroutine network_clear_null_edges subroutine network_check_topology_consistency ( net ) class ( network_t ), intent ( inout ) :: net integer ( kind = i4 ) :: node_id , edge_id , i , j logical :: is_consistent is_consistent = . true . ! loop over nodes and check if they are in their respective edges do node_id = 1 , net % num_nodes if (. not . allocated ( net % nodes ( node_id )% edges )) then if (. not . net % nodes ( node_id )% degree == 0 ) then call log_write ( LOG_WARNING , 'Node' , node_id , . false .) call log_write ( LOG_WARNING , 'has degree' , net % nodes ( node_id )% degree , . false .) call log_write ( LOG_WARNING , 'but no edges' ) is_consistent = . false . cycle end if end if do i = 1 , net % nodes ( node_id )% degree edge_id = net % nodes ( node_id )% edges ( i ) ! check if the node is in the edge if ( findloc ( net % edges ( edge_id )% nodes , node_id , dim = 1 ) == 0 ) then call log_write ( LOG_WARNING , 'Node' , node_id , . false .) call log_write ( LOG_WARNING , 'is not in edge' , edge_id ) is_consistent = . false . end if end do end do ! loop over edges and check if they are in their respective nodes do edge_id = 1 , net % num_edges if (. not . allocated ( net % edges ( edge_id )% nodes )) then if (. not . net % edges ( edge_id )% order == - 1 ) then call log_write ( LOG_WARNING , 'Edge' , edge_id , . false .) call log_write ( LOG_WARNING , 'has order' , net % edges ( edge_id )% order , . false .) call log_write ( LOG_WARNING , 'but no nodes' ) is_consistent = . false . cycle end if end if do j = 1 , net % edges ( edge_id )% order + 1 node_id = net % edges ( edge_id )% nodes ( j ) ! check if the edge is in the node if ( findloc ( net % nodes ( node_id )% edges , edge_id , dim = 1 ) == 0 ) then call log_write ( LOG_WARNING , 'Edge' , edge_id , . false .) call log_write ( LOG_WARNING , 'is not in node' , node_id ) is_consistent = . false . end if end do end do net % props % checked_topology_consistency = is_consistent if (. not . is_consistent ) then call log_write ( LOG_ERROR , 'Topology is not consistent' ) error stop '' else call log_write ( LOG_DEBUG , 'Topology is consistent' ) end if end subroutine network_check_topology_consistency subroutine network_init ( net , num_nodes , num_edges ) class ( network_t ) :: net integer ( kind = i4 ), intent ( in ) :: num_nodes , num_edges net % num_nodes = num_nodes net % num_edges = num_edges allocate ( net % nodes ( num_nodes )) allocate ( net % edges ( num_edges )) net % nodes (:)% degree = 0 net % edges (:)% order = - 1 end subroutine !> Constructor for the network type. !> It initializes the number of nodes and edges, and allocates memory for the nodes and edges arrays. !> @param net The network object to be initialized. !> @param num_nodes The number of nodes in the network. !> @param num_edges The number of edges in the network. !> @note This subroutine allocates memory for the nodes and edges arrays based on the provided sizes. !> @note The arrays are allocated with the sizes specified by num_nodes and num_edges. function network_new ( num_nodes , num_edges ) result ( net ) integer ( kind = i4 ), intent ( in ) :: num_nodes , num_edges type ( network_t ) :: net call net % init ( num_nodes , num_edges ) end function network_new !> Constructor for the hyperedge type. !> It initializes the ID and order of the hyperedge, and allocates memory for the nodes array. !> @param order The order of the hyperedge. !> @note This subroutine allocates memory for the nodes array based on the provided size. elemental function hyperedge_new ( order ) result ( edge ) integer ( kind = i4 ), intent ( in ) :: order type ( hyperedge_t ) :: edge edge % order = order allocate ( edge % nodes ( order + 1 )) end function hyperedge_new !> Constructor for the hyperedge type from a list of nodes. function hyperedge_new_from_nodes_list ( nodes ) result ( edge ) integer ( kind = i4 ), intent ( in ) :: nodes (:) type ( hyperedge_t ) :: edge edge % order = size ( nodes ) - 1 allocate ( edge % nodes ( size ( nodes ))) edge % nodes = nodes end function hyperedge_new_from_nodes_list !> Subroutine to build edges from nodes in the network. !> It iterates over each node and assigns the corresponding edges to the hyperedges. !> @param net The network object containing the nodes and edges. !> @note This subroutine modifies the edges of the network based on the nodes' connections. !> @note The edges are built by iterating over each node and assigning the corresponding edges to the hyperedges. !> @note The last_edge_index array is used to keep track of the last index for each hyperedge. subroutine network_build_edges_from_nodes ( net ) class ( network_t ) :: net integer ( kind = i4 ) :: id_edge , i , j integer ( kind = i4 ) :: last_edge_index ( net % num_edges ) last_edge_index = 0 ! Loop over each node in the network do i = 1 , net % num_nodes ! Loop over each hyperedge that the node belongs to do j = 1 , net % nodes ( i )% degree ! Add the node to the corresponding hyperedge id_edge = net % nodes ( i )% edges ( j ) net % edges ( id_edge )% nodes ( last_edge_index ( id_edge ) + 1 ) = i last_edge_index ( id_edge ) = last_edge_index ( id_edge ) + 1 end do end do end subroutine subroutine network_build_nodes_from_edges ( net ) class ( network_t ) :: net integer ( kind = i4 ) :: node_id , edge_id , i integer ( kind = i4 ) :: last_node_index ( net % num_nodes ) last_node_index = 0 ! Loop over each hyperedge in the network do edge_id = 1 , net % num_edges ! Loop over each node that belongs to the hyperedge do i = 1 , net % edges ( edge_id )% order + 1 ! Add the hyperedge to the corresponding node node_id = net % edges ( edge_id )% nodes ( i ) net % nodes ( node_id )% edges ( last_node_index ( node_id ) + 1 ) = edge_id last_node_index ( node_id ) = last_node_index ( node_id ) + 1 end do end do end subroutine network_build_nodes_from_edges subroutine network_finalizer ( net ) type ( network_t ), intent ( inout ) :: net call net % destroy () end subroutine network_finalizer subroutine network_destroy ( net ) class ( network_t ), intent ( inout ) :: net integer ( kind = i4 ) :: i ! Deallocate the edges and nodes arrays do i = 1 , net % num_nodes if ( allocated ( net % nodes ( i )% edges )) deallocate ( net % nodes ( i )% edges ) if ( allocated ( net % nodes ( i )% dual_nodes )) deallocate ( net % nodes ( i )% dual_nodes ) end do do i = 1 , net % num_edges if ( allocated ( net % edges ( i )% nodes )) deallocate ( net % edges ( i )% nodes ) if ( allocated ( net % edges ( i )% dual_edges )) deallocate ( net % edges ( i )% dual_edges ) end do if ( allocated ( net % nodes )) deallocate ( net % nodes ) if ( allocated ( net % edges )) deallocate ( net % edges ) net % num_nodes = 0 net % num_edges = 0 end subroutine network_destroy subroutine network_print_nodes_and_edges ( net ) class ( network_t ), intent ( in ) :: net integer ( kind = i4 ) :: i ! Print each node write ( * , fmt_general ) 'Nodes:' do i = 1 , net % num_nodes if ( net % nodes ( i )% degree > 0 ) then write ( * , fmt_general ) 'Node' , i , 'degree:' , net % nodes ( i )% degree , 'edges:' , net % nodes ( i )% edges else write ( * , fmt_general ) 'Node' , i , 'degree:' , net % nodes ( i )% degree , ' (isolated)' end if end do ! Print each hyperedge write ( * , fmt_general ) 'Hyperedges:' do i = 1 , net % num_edges if ( net % edges ( i )% order >= 0 ) then write ( * , fmt_general ) 'Hyperedge' , i , 'order:' , net % edges ( i )% order , '(' , net % edges ( i )% order + 1 , 'nodes )' , & 'nodes:' , net % edges ( i )% nodes else write ( * , fmt_general ) 'Hyperedge' , i , 'order:' , net % edges ( i )% order , ' (isolated)' end if end do end subroutine end module","tags":"","url":"sourcefile/network.f90.html"},{"title":"kinds.f90 – HyperSIS","text":"Files dependent on this one sourcefile~~kinds.f90~~AfferentGraph sourcefile~kinds.f90 kinds.f90 sourcefile~common.f90 common.f90 sourcefile~common.f90->sourcefile~kinds.f90 sourcefile~network.f90 network.f90 sourcefile~common.f90->sourcefile~network.f90 sourcefile~network_io.f90 network_io.f90 sourcefile~common.f90->sourcefile~network_io.f90 sourcefile~dynamics.f90 dynamics.f90 sourcefile~common.f90->sourcefile~dynamics.f90 sourcefile~dynamics_base.f90 dynamics_base.f90 sourcefile~dynamics_base.f90->sourcefile~kinds.f90 sourcefile~dynamics_base.f90->sourcefile~network.f90 sourcefile~dynamics_chooser.f90 dynamics_chooser.f90 sourcefile~dynamics_chooser.f90->sourcefile~kinds.f90 sourcefile~dynamics_chooser.f90->sourcefile~dynamics_base.f90 sourcefile~dynamics_hb_oga.f90 dynamics_HB_OGA.f90 sourcefile~dynamics_chooser.f90->sourcefile~dynamics_hb_oga.f90 sourcefile~dynamics_nb_oga.f90 dynamics_NB_OGA.f90 sourcefile~dynamics_chooser.f90->sourcefile~dynamics_nb_oga.f90 sourcefile~dynamics_hb_oga.f90->sourcefile~kinds.f90 sourcefile~dynamics_hb_oga.f90->sourcefile~dynamics_base.f90 sourcefile~dynamics_hb_oga.f90->sourcefile~network.f90 sourcefile~dynamics_nb_oga.f90->sourcefile~kinds.f90 sourcefile~dynamics_nb_oga.f90->sourcefile~dynamics_base.f90 sourcefile~dynamics_nb_oga.f90->sourcefile~network.f90 sourcefile~network.f90->sourcefile~kinds.f90 sourcefile~network_io.f90->sourcefile~kinds.f90 sourcefile~network_io.f90->sourcefile~network.f90 sourcefile~dynamics.f90->sourcefile~dynamics_base.f90 sourcefile~dynamics.f90->sourcefile~dynamics_chooser.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module hyperSIS_kinds_mod use , intrinsic :: iso_fortran_env , only : & sp => real32 , & ! single precision, range: -3.40282347E+38 to 3.40282347E+38, smallest positive: 1.17549435E-38 dp => real64 , & ! double precision, range: -1.7976931348623157E+308 to 1.7976931348623157E+308, smallest positive: 2.2250738585072014E-308 qp => real128 , & i1 => int8 , & ! 1 byte integer, range: -128 to 127 i2 => int16 , & ! 2 byte integer, range: -32768 to 32767 i4 => int32 , & ! 4 byte integer, range: -2147483648 to 2147483647 i8 => int64 ! 8 byte integer, range: -9223372036854775808 to 9223372036854775807 implicit none private !> Interface for the swap subroutine. interface swap module procedure swap_int , swap_real end interface character ( len =* ), parameter :: fmt_general = '(*(g0,x))' character ( len =* ), parameter :: fmt_comma = '(*(g0,\",\"))' character ( len =* ), parameter :: fmt_comma_pair = '(g0,\",\",g0)' public :: sp , dp , i1 , i2 , i4 , i8 public :: fmt_general , fmt_comma , count_integers_from_string public :: swap contains subroutine swap_int ( a , b ) integer ( kind = i4 ), intent ( inout ) :: a , b integer ( kind = i4 ) :: temp temp = a a = b b = temp end subroutine swap_int subroutine swap_real ( a , b ) real ( kind = dp ), intent ( inout ) :: a , b real ( kind = dp ) :: temp temp = a a = b b = temp end subroutine swap_real function count_integers_from_string ( str ) result ( count ) character ( len =* ), intent ( in ) :: str integer ( kind = i4 ) :: count integer ( kind = i4 ) :: i , len_str logical :: in_number len_str = len_trim ( str ) count = 0 in_number = . false . do i = 1 , len_str if (( str ( i : i ) == ' ' ) . or . ( str ( i : i ) == ',' )) then if ( in_number ) then count = count + 1 in_number = . false . end if else in_number = . true . end if end do if ( in_number ) count = count + 1 end function count_integers_from_string end module hyperSIS_kinds_mod","tags":"","url":"sourcefile/kinds.f90.html"},{"title":"common.f90 – HyperSIS","text":"This file depends on sourcefile~~common.f90~~EfferentGraph sourcefile~common.f90 common.f90 sourcefile~dynamics.f90 dynamics.f90 sourcefile~common.f90->sourcefile~dynamics.f90 sourcefile~kinds.f90 kinds.f90 sourcefile~common.f90->sourcefile~kinds.f90 sourcefile~network.f90 network.f90 sourcefile~common.f90->sourcefile~network.f90 sourcefile~network_io.f90 network_io.f90 sourcefile~common.f90->sourcefile~network_io.f90 sourcefile~dynamics_base.f90 dynamics_base.f90 sourcefile~dynamics.f90->sourcefile~dynamics_base.f90 sourcefile~dynamics_chooser.f90 dynamics_chooser.f90 sourcefile~dynamics.f90->sourcefile~dynamics_chooser.f90 sourcefile~network.f90->sourcefile~kinds.f90 sourcefile~network_io.f90->sourcefile~kinds.f90 sourcefile~network_io.f90->sourcefile~network.f90 sourcefile~dynamics_base.f90->sourcefile~kinds.f90 sourcefile~dynamics_base.f90->sourcefile~network.f90 sourcefile~dynamics_chooser.f90->sourcefile~kinds.f90 sourcefile~dynamics_chooser.f90->sourcefile~dynamics_base.f90 sourcefile~dynamics_hb_oga.f90 dynamics_HB_OGA.f90 sourcefile~dynamics_chooser.f90->sourcefile~dynamics_hb_oga.f90 sourcefile~dynamics_nb_oga.f90 dynamics_NB_OGA.f90 sourcefile~dynamics_chooser.f90->sourcefile~dynamics_nb_oga.f90 sourcefile~dynamics_hb_oga.f90->sourcefile~kinds.f90 sourcefile~dynamics_hb_oga.f90->sourcefile~network.f90 sourcefile~dynamics_hb_oga.f90->sourcefile~dynamics_base.f90 sourcefile~dynamics_nb_oga.f90->sourcefile~kinds.f90 sourcefile~dynamics_nb_oga.f90->sourcefile~network.f90 sourcefile~dynamics_nb_oga.f90->sourcefile~dynamics_base.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module hyperSIS_program_common_mod use hyperSIS_kinds_mod , only : dp , i4 use hyperSIS_network_mod , only : network_t use hyperSIS_network_io_mod , only : network_import use hyperSIS_dynamics_mod , only : dyn_parameters_t , net_state_base_t use rndgen_mod implicit none private interface subroutine proc_net_state_gen ( net , state , gen ) import :: net_state_base_t , rndgen , network_t class ( network_t ), intent ( in ) :: net class ( net_state_base_t ), intent ( inout ) :: state class ( rndgen ), intent ( inout ) :: gen end subroutine proc_net_state_gen subroutine proc_export_states ( net , state , nodes_filename , edges_filename ) import :: net_state_base_t , rndgen , network_t class ( network_t ), intent ( in ) :: net class ( net_state_base_t ), intent ( inout ) :: state character ( len =* ), intent ( in ) :: nodes_filename , edges_filename end subroutine proc_export_states end interface public :: proc_net_state_gen , proc_export_states public :: check_qs_method public :: read_network public :: set_dyn_params public :: set_initial_number_of_infected_nodes public :: get_path_prefix public :: check_export_nodes_and_edges_state contains subroutine export_nodes_and_edges_state ( net , state , nodes_filename , edges_filename ) class ( network_t ), intent ( in ) :: net class ( net_state_base_t ), intent ( inout ) :: state character ( len =* ), intent ( in ) :: nodes_filename , edges_filename call state % export_nodes_states ( net , trim ( adjustl ( nodes_filename ))) call state % export_edges_states ( net , trim ( adjustl ( edges_filename ))) end subroutine subroutine do_not_export_nodes_and_edges_state ( net , state , nodes_filename , edges_filename ) class ( network_t ), intent ( in ) :: net class ( net_state_base_t ), intent ( inout ) :: state character ( len =* ), intent ( in ) :: nodes_filename , edges_filename end subroutine subroutine check_export_nodes_and_edges_state ( export_states , input_export_states ) procedure ( proc_export_states ), pointer :: export_states logical , intent ( in ) :: input_export_states if ( input_export_states ) then export_states => export_nodes_and_edges_state else export_states => do_not_export_nodes_and_edges_state end if end subroutine check_export_nodes_and_edges_state !> QS reactivation (randomly chosen node) subroutine reactivate_random_node ( net , state , gen ) class ( network_t ), intent ( in ) :: net class ( net_state_base_t ), intent ( inout ) :: state class ( rndgen ), intent ( inout ) :: gen integer ( kind = i4 ) :: node_id if ( state % get_num_infected () == 0 ) then node_id = gen % int ( 1 , net % num_nodes ) call state % add_infected ( net , node_id ) end if end subroutine reactivate_random_node !> Do nothing after subroutine do_nothing ( net , state , gen ) class ( network_t ), intent ( in ) :: net class ( net_state_base_t ), intent ( inout ) :: state class ( rndgen ), intent ( inout ) :: gen end subroutine do_nothing !> Check which method to use after dynamics step subroutine check_qs_method ( after_dynamics_step , input_use_qs ) procedure ( proc_net_state_gen ), pointer :: after_dynamics_step logical , intent ( in ) :: input_use_qs if ( input_use_qs ) then after_dynamics_step => reactivate_random_node else after_dynamics_step => do_nothing end if end subroutine subroutine set_dyn_params ( net , dyn_params , par_b , par_theta ) class ( network_t ), intent ( in ) :: net type ( dyn_parameters_t ), intent ( inout ) :: dyn_params real ( kind = dp ), intent ( in ) :: par_b , par_theta integer ( kind = i4 ) :: edge_order ! Set parameters call dyn_params % init ( net ) ! Fill the beta and theta parameters do edge_order = 1 , net % max_order dyn_params % beta ( edge_order ) = 1.0_dp + par_b * ( edge_order - 1 ) dyn_params % theta ( edge_order ) = ceiling ( 1.0_dp + ( edge_order - 1 ) * par_theta ) end do end subroutine set_dyn_params subroutine read_network ( net , edges_filename ) type ( network_t ), intent ( inout ) :: net character ( len =* ), intent ( in ) :: edges_filename call network_import ( net , trim ( adjustl ( edges_filename ))) end subroutine read_network subroutine set_initial_number_of_infected_nodes ( net , inf_fraction , initial_number ) class ( network_t ), intent ( in ) :: net real ( kind = dp ), intent ( inout ) :: inf_fraction integer ( kind = i4 ), intent ( inout ) :: initial_number ! Check initial number of infected nodes if ( initial_number > 0 ) then inf_fraction = real ( initial_number , dp ) / real ( net % num_nodes , dp ) if ( inf_fraction < 0.0_dp . or . inf_fraction > 1.0_dp ) error stop 'Initial number of infected nodes must be between 0 and network size' end if end subroutine set_initial_number_of_infected_nodes !> Build the prefix and remove old files function get_path_prefix ( tmp_prefix , remove_files ) result ( prefix ) character ( len =* ), intent ( in ) :: tmp_prefix logical , intent ( in ) :: remove_files character ( len = :), allocatable :: prefix prefix = trim ( adjustl ( tmp_prefix )) if (. not . prefix ( len ( prefix ): len ( prefix )) == '/' ) then ! Append a trailing underscore if it is not a directory prefix = prefix // '_' end if ! Remove old files with the same prefix call system ( 'mkdir -pv ' // prefix // 'basedir/' ) if ( remove_files ) call system ( 'rm -vf ' // prefix // '*time*.dat' ) end function get_path_prefix end module hyperSIS_program_common_mod","tags":"","url":"sourcefile/common.f90.html"}]}